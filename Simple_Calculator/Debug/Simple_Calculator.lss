
AVRASM ver. 2.1.57  C:\Users\mohamed\Documents\Atmel Studio\6.2\Simple_Calculator\Simple_Calculator\Simple_Calculator.asm Fri May 24 00:03:07 2019

[builtin](2): Including file 'C:\Program Files (x86)\Atmel\Atmel Toolchain\AVR Assembler\Native\2.1.1175\avrassembler\Include\m32Adef.inc'
C:\Users\mohamed\Documents\Atmel Studio\6.2\Simple_Calculator\Simple_Calculator\Simple_Calculator.asm(10): Including file 'C:\Users\mohamed\Documents\Atmel Studio\6.2\Simple_Calculator\Simple_Calculator\LCD_MODULE.inc'
C:\Users\mohamed\Documents\Atmel Studio\6.2\Simple_Calculator\Simple_Calculator\LCD_MODULE.inc(7): Including file 'C:\Users\mohamed\Documents\Atmel Studio\6.2\Simple_Calculator\Simple_Calculator\Micro_Configration.INC'
C:\Users\mohamed\Documents\Atmel Studio\6.2\Simple_Calculator\Simple_Calculator\Simple_Calculator.asm(11): Including file 'C:\Users\mohamed\Documents\Atmel Studio\6.2\Simple_Calculator\Simple_Calculator\KEYPAD.inc'
C:\Users\mohamed\Documents\Atmel Studio\6.2\Simple_Calculator\Simple_Calculator\Simple_Calculator.asm(12): Including file 'C:\Users\mohamed\Documents\Atmel Studio\6.2\Simple_Calculator\Simple_Calculator\CALC.inc'
C:\Users\mohamed\Documents\Atmel Studio\6.2\Simple_Calculator\Simple_Calculator\Simple_Calculator.asm(13): Including file 'C:\Users\mohamed\Documents\Atmel Studio\6.2\Simple_Calculator\Simple_Calculator\convert_to_string.inc'
C:\Users\mohamed\Documents\Atmel Studio\6.2\Simple_Calculator\Simple_Calculator\Simple_Calculator.asm(14): Including file 'C:\Users\mohamed\Documents\Atmel Studio\6.2\Simple_Calculator\Simple_Calculator\def_reg.inc'
                 
                 /*
                 
                 ;***** Created: 2011-02-09 12:03 ******* Source: ATmega32A.xml ***********
                 ;*************************************************************************
                 ;* A P P L I C A T I O N   N O T E   F O R   T H E   A V R   F A M I L Y
                 ;* 
                 ;* Number            : AVR000
                 ;* File Name         : "m32Adef.inc"
                 ;* Title             : Register/Bit Definitions for the ATmega32A
                 ;* Date              : 2011-02-09
                 ;* Version           : 2.35
                 ;* Support E-mail    : avr@atmel.com
                 ;* Target MCU        : ATmega32A
                 ;* 
                 ;* DESCRIPTION
                 ;* When including this file in the assembly program file, all I/O register 
                 ;* names and I/O register bit names appearing in the data book can be used.
                 ;* In addition, the six registers forming the three data pointers X, Y and 
                 ;* Z have been assigned names XL - ZH. Highest RAM address for Internal 
                 ;* SRAM is also defined 
                 ;* 
                 ;* The Register names are represented by their hexadecimal address.
                 ;* 
                 ;* The Register Bit names are represented by their bit number (0-7).
                 ;* 
                 ;* Please observe the difference in using the bit names with instructions
                 ;* such as "sbr"/"cbr" (set/clear bit in register) and "sbrs"/"sbrc"
                 ;* (skip if bit in register set/cleared). The following example illustrates
                 ;* this:
                 ;* 
                 ;* in    r16,PORTB             ;read PORTB latch
                 ;* sbr   r16,(1<<PB6)+(1<<PB5) ;set PB6 and PB5 (use masks, not bit#)
                 ;* out   PORTB,r16             ;output to PORTB
                 ;* 
                 ;* in    r16,TIFR              ;read the Timer Interrupt Flag Register
                 ;* sbrc  r16,TOV0              ;test the overflow flag (use bit#)
                 ;* rjmp  TOV0_is_set           ;jump if set
                 ;* ...                         ;otherwise do something else
                 ;*************************************************************************
                 
                 #ifndef _M32ADEF_INC_
                 #define _M32ADEF_INC_
                 
                 
                 #pragma partinc 0
                 
                 ; ***** SPECIFY DEVICE ***************************************************
                 .device ATmega32A
                 #pragma AVRPART ADMIN PART_NAME ATmega32A
                 .equ	SIGNATURE_000	= 0x1e
                 .equ	SIGNATURE_001	= 0x95
                 .equ	SIGNATURE_002	= 0x02
                 
                 #pragma AVRPART CORE CORE_VERSION V2E
                 
                 
                 ; ***** I/O REGISTER DEFINITIONS *****************************************
                 ; NOTE:
                 ; Definitions marked "MEMORY MAPPED"are extended I/O ports
                 ; and cannot be used with IN/OUT instructions
                 .equ	SREG	= 0x3f
                 .equ	SPL	= 0x3d
                 .equ	SPH	= 0x3e
                 .equ	OCR0	= 0x3c
                 .equ	GICR	= 0x3b
                 .equ	GIFR	= 0x3a
                 .equ	TIMSK	= 0x39
                 .equ	TIFR	= 0x38
                 .equ	SPMCR	= 0x37
                 .equ	TWCR	= 0x36
                 .equ	MCUCR	= 0x35
                 .equ	MCUCSR	= 0x34
                 .equ	TCCR0	= 0x33
                 .equ	TCNT0	= 0x32
                 .equ	OSCCAL	= 0x31
                 .equ	OCDR	= 0x31
                 .equ	SFIOR	= 0x30
                 .equ	TCCR1A	= 0x2f
                 .equ	TCCR1B	= 0x2e
                 .equ	TCNT1L	= 0x2c
                 .equ	TCNT1H	= 0x2d
                 .equ	OCR1AL	= 0x2a
                 .equ	OCR1AH	= 0x2b
                 .equ	OCR1BL	= 0x28
                 .equ	OCR1BH	= 0x29
                 .equ	ICR1L	= 0x26
                 .equ	ICR1H	= 0x27
                 .equ	TCCR2	= 0x25
                 .equ	TCNT2	= 0x24
                 .equ	OCR2	= 0x23
                 .equ	ASSR	= 0x22
                 .equ	WDTCR	= 0x21
                 .equ	UBRRH	= 0x20
                 .equ	UCSRC	= 0x20
                 .equ	EEARL	= 0x1e
                 .equ	EEARH	= 0x1f
                 .equ	EEDR	= 0x1d
                 .equ	EECR	= 0x1c
                 .equ	PORTA	= 0x1b
                 .equ	DDRA	= 0x1a
                 .equ	PINA	= 0x19
                 .equ	PORTB	= 0x18
                 .equ	DDRB	= 0x17
                 .equ	PINB	= 0x16
                 .equ	PORTC	= 0x15
                 .equ	DDRC	= 0x14
                 .equ	PINC	= 0x13
                 .equ	PORTD	= 0x12
                 .equ	DDRD	= 0x11
                 .equ	PIND	= 0x10
                 .equ	SPDR	= 0x0f
                 .equ	SPSR	= 0x0e
                 .equ	SPCR	= 0x0d
                 .equ	UDR	= 0x0c
                 .equ	UCSRA	= 0x0b
                 .equ	UCSRB	= 0x0a
                 .equ	UBRRL	= 0x09
                 .equ	ACSR	= 0x08
                 .equ	ADMUX	= 0x07
                 .equ	ADCSRA	= 0x06
                 .equ	ADCH	= 0x05
                 .equ	ADCL	= 0x04
                 .equ	TWDR	= 0x03
                 .equ	TWAR	= 0x02
                 .equ	TWSR	= 0x01
                 .equ	TWBR	= 0x00
                 
                 
                 ; ***** BIT DEFINITIONS **************************************************
                 
                 ; ***** EEPROM ***********************
                 ; EEDR - EEPROM Data Register
                 .equ	EEDR0	= 0	; EEPROM Data Register bit 0
                 .equ	EEDR1	= 1	; EEPROM Data Register bit 1
                 .equ	EEDR2	= 2	; EEPROM Data Register bit 2
                 .equ	EEDR3	= 3	; EEPROM Data Register bit 3
                 .equ	EEDR4	= 4	; EEPROM Data Register bit 4
                 .equ	EEDR5	= 5	; EEPROM Data Register bit 5
                 .equ	EEDR6	= 6	; EEPROM Data Register bit 6
                 .equ	EEDR7	= 7	; EEPROM Data Register bit 7
                 
                 ; EECR - EEPROM Control Register
                 .equ	EERE	= 0	; EEPROM Read Enable
                 .equ	EEWE	= 1	; EEPROM Write Enable
                 .equ	EEMWE	= 2	; EEPROM Master Write Enable
                 .equ	EERIE	= 3	; EEPROM Ready Interrupt Enable
                 
                 
                 ; ***** WATCHDOG *********************
                 ; WDTCR - Watchdog Timer Control Register
                 .equ	WDP0	= 0	; Watch Dog Timer Prescaler bit 0
                 .equ	WDP1	= 1	; Watch Dog Timer Prescaler bit 1
                 .equ	WDP2	= 2	; Watch Dog Timer Prescaler bit 2
                 .equ	WDE	= 3	; Watch Dog Enable
                 .equ	WDTOE	= 4	; RW
                 .equ	WDDE	= WDTOE	; For compatibility
                 
                 
                 ; ***** EXTERNAL_INTERRUPT ***********
                 ; GICR - General Interrupt Control Register
                 .equ	GIMSK	= GICR	; For compatibility
                 .equ	IVCE	= 0	; Interrupt Vector Change Enable
                 .equ	IVSEL	= 1	; Interrupt Vector Select
                 .equ	INT2	= 5	; External Interrupt Request 2 Enable
                 .equ	INT0	= 6	; External Interrupt Request 0 Enable
                 .equ	INT1	= 7	; External Interrupt Request 1 Enable
                 
                 ; GIFR - General Interrupt Flag Register
                 .equ	INTF2	= 5	; External Interrupt Flag 2
                 .equ	INTF0	= 6	; External Interrupt Flag 0
                 .equ	INTF1	= 7	; External Interrupt Flag 1
                 
                 ; MCUCR - General Interrupt Control Register
                 .equ	ISC00	= 0	; Interrupt Sense Control 0 Bit 0
                 .equ	ISC01	= 1	; Interrupt Sense Control 0 Bit 1
                 .equ	ISC10	= 2	; Interrupt Sense Control 1 Bit 0
                 .equ	ISC11	= 3	; Interrupt Sense Control 1 Bit 1
                 
                 ; MCUCSR - MCU Control And Status Register
                 .equ	ISC2	= 6	; Interrupt Sense Control 2
                 
                 
                 ; ***** TIMER_COUNTER_0 **************
                 ; TCCR0 - Timer/Counter Control Register
                 .equ	CS00	= 0	; Clock Select 1
                 .equ	CS01	= 1	; Clock Select 1
                 .equ	CS02	= 2	; Clock Select 2
                 .equ	WGM01	= 3	; Waveform Generation Mode 1
                 .equ	CTC0	= WGM01	; For compatibility
                 .equ	COM00	= 4	; Compare match Output Mode 0
                 .equ	COM01	= 5	; Compare Match Output Mode 1
                 .equ	WGM00	= 6	; Waveform Generation Mode
                 .equ	PWM0	= WGM00	; For compatibility
                 .equ	FOC0	= 7	; Force Output Compare
                 
                 ; TCNT0 - Timer/Counter Register
                 .equ	TCNT0_0	= 0	; 
                 .equ	TCNT0_1	= 1	; 
                 .equ	TCNT0_2	= 2	; 
                 .equ	TCNT0_3	= 3	; 
                 .equ	TCNT0_4	= 4	; 
                 .equ	TCNT0_5	= 5	; 
                 .equ	TCNT0_6	= 6	; 
                 .equ	TCNT0_7	= 7	; 
                 
                 ; OCR0 - Output Compare Register
                 .equ	OCR0_0	= 0	; 
                 .equ	OCR0_1	= 1	; 
                 .equ	OCR0_2	= 2	; 
                 .equ	OCR0_3	= 3	; 
                 .equ	OCR0_4	= 4	; 
                 .equ	OCR0_5	= 5	; 
                 .equ	OCR0_6	= 6	; 
                 .equ	OCR0_7	= 7	; 
                 
                 ; TIMSK - Timer/Counter Interrupt Mask Register
                 .equ	TOIE0	= 0	; Timer/Counter0 Overflow Interrupt Enable
                 .equ	OCIE0	= 1	; Timer/Counter0 Output Compare Match Interrupt register
                 
                 ; TIFR - Timer/Counter Interrupt Flag register
                 .equ	TOV0	= 0	; Timer/Counter0 Overflow Flag
                 .equ	OCF0	= 1	; Output Compare Flag 0
                 
                 
                 ; ***** TIMER_COUNTER_2 **************
                 ; TIMSK - Timer/Counter Interrupt Mask register
                 .equ	TOIE2	= 6	; Timer/Counter2 Overflow Interrupt Enable
                 .equ	OCIE2	= 7	; Timer/Counter2 Output Compare Match Interrupt Enable
                 
                 ; TIFR - Timer/Counter Interrupt Flag Register
                 .equ	TOV2	= 6	; Timer/Counter2 Overflow Flag
                 .equ	OCF2	= 7	; Output Compare Flag 2
                 
                 ; TCCR2 - Timer/Counter2 Control Register
                 .equ	CS20	= 0	; Clock Select bit 0
                 .equ	CS21	= 1	; Clock Select bit 1
                 .equ	CS22	= 2	; Clock Select bit 2
                 .equ	WGM21	= 3	; Clear Timer/Counter2 on Compare Match
                 .equ	CTC2	= WGM21	; For compatibility
                 .equ	COM20	= 4	; Compare Output Mode bit 0
                 .equ	COM21	= 5	; Compare Output Mode bit 1
                 .equ	WGM20	= 6	; Pulse Width Modulator Enable
                 .equ	PWM2	= WGM20	; For compatibility
                 .equ	FOC2	= 7	; Force Output Compare
                 
                 ; TCNT2 - Timer/Counter2
                 .equ	TCNT2_0	= 0	; Timer/Counter 2 bit 0
                 .equ	TCNT2_1	= 1	; Timer/Counter 2 bit 1
                 .equ	TCNT2_2	= 2	; Timer/Counter 2 bit 2
                 .equ	TCNT2_3	= 3	; Timer/Counter 2 bit 3
                 .equ	TCNT2_4	= 4	; Timer/Counter 2 bit 4
                 .equ	TCNT2_5	= 5	; Timer/Counter 2 bit 5
                 .equ	TCNT2_6	= 6	; Timer/Counter 2 bit 6
                 .equ	TCNT2_7	= 7	; Timer/Counter 2 bit 7
                 
                 ; OCR2 - Timer/Counter2 Output Compare Register
                 .equ	OCR2_0	= 0	; Timer/Counter2 Output Compare Register Bit 0
                 .equ	OCR2_1	= 1	; Timer/Counter2 Output Compare Register Bit 1
                 .equ	OCR2_2	= 2	; Timer/Counter2 Output Compare Register Bit 2
                 .equ	OCR2_3	= 3	; Timer/Counter2 Output Compare Register Bit 3
                 .equ	OCR2_4	= 4	; Timer/Counter2 Output Compare Register Bit 4
                 .equ	OCR2_5	= 5	; Timer/Counter2 Output Compare Register Bit 5
                 .equ	OCR2_6	= 6	; Timer/Counter2 Output Compare Register Bit 6
                 .equ	OCR2_7	= 7	; Timer/Counter2 Output Compare Register Bit 7
                 
                 ; ASSR - Asynchronous Status Register
                 .equ	TCR2UB	= 0	; Timer/counter Control Register2 Update Busy
                 .equ	OCR2UB	= 1	; Output Compare Register2 Update Busy
                 .equ	TCN2UB	= 2	; Timer/Counter2 Update Busy
                 .equ	AS2	= 3	; Asynchronous Timer/counter2
                 
                 
                 ; ***** TIMER_COUNTER_1 **************
                 ; TIMSK - Timer/Counter Interrupt Mask Register
                 .equ	TOIE1	= 2	; Timer/Counter1 Overflow Interrupt Enable
                 .equ	OCIE1B	= 3	; Timer/Counter1 Output CompareB Match Interrupt Enable
                 .equ	OCIE1A	= 4	; Timer/Counter1 Output CompareA Match Interrupt Enable
                 .equ	TICIE1	= 5	; Timer/Counter1 Input Capture Interrupt Enable
                 
                 ; TIFR - Timer/Counter Interrupt Flag register
                 .equ	TOV1	= 2	; Timer/Counter1 Overflow Flag
                 .equ	OCF1B	= 3	; Output Compare Flag 1B
                 .equ	OCF1A	= 4	; Output Compare Flag 1A
                 .equ	ICF1	= 5	; Input Capture Flag 1
                 
                 ; TCCR1A - Timer/Counter1 Control Register A
                 .equ	WGM10	= 0	; Waveform Generation Mode
                 .equ	PWM10	= WGM10	; For compatibility
                 .equ	WGM11	= 1	; Waveform Generation Mode
                 .equ	PWM11	= WGM11	; For compatibility
                 .equ	FOC1B	= 2	; Force Output Compare 1B
                 .equ	FOC1A	= 3	; Force Output Compare 1A
                 .equ	COM1B0	= 4	; Compare Output Mode 1B, bit 0
                 .equ	COM1B1	= 5	; Compare Output Mode 1B, bit 1
                 .equ	COM1A0	= 6	; Compare Ouput Mode 1A, bit 0
                 .equ	COM1A1	= 7	; Compare Output Mode 1A, bit 1
                 
                 ; TCCR1B - Timer/Counter1 Control Register B
                 .equ	CS10	= 0	; Prescaler source of Timer/Counter 1
                 .equ	CS11	= 1	; Prescaler source of Timer/Counter 1
                 .equ	CS12	= 2	; Prescaler source of Timer/Counter 1
                 .equ	WGM12	= 3	; Waveform Generation Mode
                 .equ	CTC10	= WGM12	; For compatibility
                 .equ	CTC1	= WGM12	; For compatibility
                 .equ	WGM13	= 4	; Waveform Generation Mode
                 .equ	CTC11	= WGM13	; For compatibility
                 .equ	ICES1	= 6	; Input Capture 1 Edge Select
                 .equ	ICNC1	= 7	; Input Capture 1 Noise Canceler
                 
                 
                 ; ***** SPI **************************
                 ; SPDR - SPI Data Register
                 .equ	SPDR0	= 0	; SPI Data Register bit 0
                 .equ	SPDR1	= 1	; SPI Data Register bit 1
                 .equ	SPDR2	= 2	; SPI Data Register bit 2
                 .equ	SPDR3	= 3	; SPI Data Register bit 3
                 .equ	SPDR4	= 4	; SPI Data Register bit 4
                 .equ	SPDR5	= 5	; SPI Data Register bit 5
                 .equ	SPDR6	= 6	; SPI Data Register bit 6
                 .equ	SPDR7	= 7	; SPI Data Register bit 7
                 
                 ; SPSR - SPI Status Register
                 .equ	SPI2X	= 0	; Double SPI Speed Bit
                 .equ	WCOL	= 6	; Write Collision Flag
                 .equ	SPIF	= 7	; SPI Interrupt Flag
                 
                 ; SPCR - SPI Control Register
                 .equ	SPR0	= 0	; SPI Clock Rate Select 0
                 .equ	SPR1	= 1	; SPI Clock Rate Select 1
                 .equ	CPHA	= 2	; Clock Phase
                 .equ	CPOL	= 3	; Clock polarity
                 .equ	MSTR	= 4	; Master/Slave Select
                 .equ	DORD	= 5	; Data Order
                 .equ	SPE	= 6	; SPI Enable
                 .equ	SPIE	= 7	; SPI Interrupt Enable
                 
                 
                 ; ***** USART ************************
                 ; UDR - USART I/O Data Register
                 .equ	UDR0	= 0	; USART I/O Data Register bit 0
                 .equ	UDR1	= 1	; USART I/O Data Register bit 1
                 .equ	UDR2	= 2	; USART I/O Data Register bit 2
                 .equ	UDR3	= 3	; USART I/O Data Register bit 3
                 .equ	UDR4	= 4	; USART I/O Data Register bit 4
                 .equ	UDR5	= 5	; USART I/O Data Register bit 5
                 .equ	UDR6	= 6	; USART I/O Data Register bit 6
                 .equ	UDR7	= 7	; USART I/O Data Register bit 7
                 
                 ; UCSRA - USART Control and Status Register A
                 .equ	USR	= UCSRA	; For compatibility
                 .equ	MPCM	= 0	; Multi-processor Communication Mode
                 .equ	U2X	= 1	; Double the USART transmission speed
                 .equ	UPE	= 2	; Parity Error
                 .equ	PE	= UPE	; For compatibility
                 .equ	DOR	= 3	; Data overRun
                 .equ	FE	= 4	; Framing Error
                 .equ	UDRE	= 5	; USART Data Register Empty
                 .equ	TXC	= 6	; USART Transmitt Complete
                 .equ	RXC	= 7	; USART Receive Complete
                 
                 ; UCSRB - USART Control and Status Register B
                 .equ	UCR	= UCSRB	; For compatibility
                 .equ	TXB8	= 0	; Transmit Data Bit 8
                 .equ	RXB8	= 1	; Receive Data Bit 8
                 .equ	UCSZ2	= 2	; Character Size
                 .equ	CHR9	= UCSZ2	; For compatibility
                 .equ	TXEN	= 3	; Transmitter Enable
                 .equ	RXEN	= 4	; Receiver Enable
                 .equ	UDRIE	= 5	; USART Data register Empty Interrupt Enable
                 .equ	TXCIE	= 6	; TX Complete Interrupt Enable
                 .equ	RXCIE	= 7	; RX Complete Interrupt Enable
                 
                 ; UCSRC - USART Control and Status Register C
                 .equ	UCPOL	= 0	; Clock Polarity
                 .equ	UCSZ0	= 1	; Character Size
                 .equ	UCSZ1	= 2	; Character Size
                 .equ	USBS	= 3	; Stop Bit Select
                 .equ	UPM0	= 4	; Parity Mode Bit 0
                 .equ	UPM1	= 5	; Parity Mode Bit 1
                 .equ	UMSEL	= 6	; USART Mode Select
                 .equ	URSEL	= 7	; Register Select
                 
                 .equ	UBRRHI	= UBRRH	; For compatibility
                 
                 ; ***** ANALOG_COMPARATOR ************
                 ; SFIOR - Special Function IO Register
                 .equ	ACME	= 3	; Analog Comparator Multiplexer Enable
                 
                 ; ACSR - Analog Comparator Control And Status Register
                 .equ	ACIS0	= 0	; Analog Comparator Interrupt Mode Select bit 0
                 .equ	ACIS1	= 1	; Analog Comparator Interrupt Mode Select bit 1
                 .equ	ACIC	= 2	; Analog Comparator Input Capture Enable
                 .equ	ACIE	= 3	; Analog Comparator Interrupt Enable
                 .equ	ACI	= 4	; Analog Comparator Interrupt Flag
                 .equ	ACO	= 5	; Analog Compare Output
                 .equ	ACBG	= 6	; Analog Comparator Bandgap Select
                 .equ	ACD	= 7	; Analog Comparator Disable
                 
                 
                 ; ***** AD_CONVERTER *****************
                 ; ADMUX - The ADC multiplexer Selection Register
                 .equ	MUX0	= 0	; Analog Channel and Gain Selection Bits
                 .equ	MUX1	= 1	; Analog Channel and Gain Selection Bits
                 .equ	MUX2	= 2	; Analog Channel and Gain Selection Bits
                 .equ	MUX3	= 3	; Analog Channel and Gain Selection Bits
                 .equ	MUX4	= 4	; Analog Channel and Gain Selection Bits
                 .equ	ADLAR	= 5	; Left Adjust Result
                 .equ	REFS0	= 6	; Reference Selection Bit 0
                 .equ	REFS1	= 7	; Reference Selection Bit 1
                 
                 ; ADCSRA - The ADC Control and Status register
                 .equ	ADCSR	= ADCSRA	; For compatibility
                 .equ	ADPS0	= 0	; ADC  Prescaler Select Bits
                 .equ	ADPS1	= 1	; ADC  Prescaler Select Bits
                 .equ	ADPS2	= 2	; ADC  Prescaler Select Bits
                 .equ	ADIE	= 3	; ADC Interrupt Enable
                 .equ	ADIF	= 4	; ADC Interrupt Flag
                 .equ	ADATE	= 5	; When this bit is written to one,the Timer/Counter2 prescaler will be reset.The bit will be cleared by hardware after the operation is performed.Writing a zero to this bit will have no effect.This bit will always be read as zero if Timer/C                 ounter2 is clocked by the internal CPU clock.If this bit is written when Timer/Counter2 is operating in asynchronous mode,the bit will remain one until the prescaler has been reset.
                 .equ	ADFR	= ADATE	; For compatibility
                 .equ	ADSC	= 6	; ADC Start Conversion
                 .equ	ADEN	= 7	; ADC Enable
                 
                 ; ADCH - ADC Data Register High Byte
                 .equ	ADCH0	= 0	; ADC Data Register High Byte Bit 0
                 .equ	ADCH1	= 1	; ADC Data Register High Byte Bit 1
                 .equ	ADCH2	= 2	; ADC Data Register High Byte Bit 2
                 .equ	ADCH3	= 3	; ADC Data Register High Byte Bit 3
                 .equ	ADCH4	= 4	; ADC Data Register High Byte Bit 4
                 .equ	ADCH5	= 5	; ADC Data Register High Byte Bit 5
                 .equ	ADCH6	= 6	; ADC Data Register High Byte Bit 6
                 .equ	ADCH7	= 7	; ADC Data Register High Byte Bit 7
                 
                 ; ADCL - ADC Data Register Low Byte
                 .equ	ADCL0	= 0	; ADC Data Register Low Byte Bit 0
                 .equ	ADCL1	= 1	; ADC Data Register Low Byte Bit 1
                 .equ	ADCL2	= 2	; ADC Data Register Low Byte Bit 2
                 .equ	ADCL3	= 3	; ADC Data Register Low Byte Bit 3
                 .equ	ADCL4	= 4	; ADC Data Register Low Byte Bit 4
                 .equ	ADCL5	= 5	; ADC Data Register Low Byte Bit 5
                 .equ	ADCL6	= 6	; ADC Data Register Low Byte Bit 6
                 .equ	ADCL7	= 7	; ADC Data Register Low Byte Bit 7
                 
                 ; SFIOR - Special Function IO Register
                 .equ	ADTS0	= 5	; ADC Auto Trigger Source 0
                 .equ	ADTS1	= 6	; ADC Auto Trigger Source 1
                 .equ	ADTS2	= 7	; ADC Auto Trigger Source 2
                 
                 
                 ; ***** PORTA ************************
                 ; PORTA - Port A Data Register
                 .equ	PORTA0	= 0	; Port A Data Register bit 0
                 .equ	PA0	= 0	; For compatibility
                 .equ	PORTA1	= 1	; Port A Data Register bit 1
                 .equ	PA1	= 1	; For compatibility
                 .equ	PORTA2	= 2	; Port A Data Register bit 2
                 .equ	PA2	= 2	; For compatibility
                 .equ	PORTA3	= 3	; Port A Data Register bit 3
                 .equ	PA3	= 3	; For compatibility
                 .equ	PORTA4	= 4	; Port A Data Register bit 4
                 .equ	PA4	= 4	; For compatibility
                 .equ	PORTA5	= 5	; Port A Data Register bit 5
                 .equ	PA5	= 5	; For compatibility
                 .equ	PORTA6	= 6	; Port A Data Register bit 6
                 .equ	PA6	= 6	; For compatibility
                 .equ	PORTA7	= 7	; Port A Data Register bit 7
                 .equ	PA7	= 7	; For compatibility
                 
                 ; DDRA - Port A Data Direction Register
                 .equ	DDA0	= 0	; Data Direction Register, Port A, bit 0
                 .equ	DDA1	= 1	; Data Direction Register, Port A, bit 1
                 .equ	DDA2	= 2	; Data Direction Register, Port A, bit 2
                 .equ	DDA3	= 3	; Data Direction Register, Port A, bit 3
                 .equ	DDA4	= 4	; Data Direction Register, Port A, bit 4
                 .equ	DDA5	= 5	; Data Direction Register, Port A, bit 5
                 .equ	DDA6	= 6	; Data Direction Register, Port A, bit 6
                 .equ	DDA7	= 7	; Data Direction Register, Port A, bit 7
                 
                 ; PINA - Port A Input Pins
                 .equ	PINA0	= 0	; Input Pins, Port A bit 0
                 .equ	PINA1	= 1	; Input Pins, Port A bit 1
                 .equ	PINA2	= 2	; Input Pins, Port A bit 2
                 .equ	PINA3	= 3	; Input Pins, Port A bit 3
                 .equ	PINA4	= 4	; Input Pins, Port A bit 4
                 .equ	PINA5	= 5	; Input Pins, Port A bit 5
                 .equ	PINA6	= 6	; Input Pins, Port A bit 6
                 .equ	PINA7	= 7	; Input Pins, Port A bit 7
                 
                 
                 ; ***** PORTB ************************
                 ; PORTB - Port B Data Register
                 .equ	PORTB0	= 0	; Port B Data Register bit 0
                 .equ	PB0	= 0	; For compatibility
                 .equ	PORTB1	= 1	; Port B Data Register bit 1
                 .equ	PB1	= 1	; For compatibility
                 .equ	PORTB2	= 2	; Port B Data Register bit 2
                 .equ	PB2	= 2	; For compatibility
                 .equ	PORTB3	= 3	; Port B Data Register bit 3
                 .equ	PB3	= 3	; For compatibility
                 .equ	PORTB4	= 4	; Port B Data Register bit 4
                 .equ	PB4	= 4	; For compatibility
                 .equ	PORTB5	= 5	; Port B Data Register bit 5
                 .equ	PB5	= 5	; For compatibility
                 .equ	PORTB6	= 6	; Port B Data Register bit 6
                 .equ	PB6	= 6	; For compatibility
                 .equ	PORTB7	= 7	; Port B Data Register bit 7
                 .equ	PB7	= 7	; For compatibility
                 
                 ; DDRB - Port B Data Direction Register
                 .equ	DDB0	= 0	; Port B Data Direction Register bit 0
                 .equ	DDB1	= 1	; Port B Data Direction Register bit 1
                 .equ	DDB2	= 2	; Port B Data Direction Register bit 2
                 .equ	DDB3	= 3	; Port B Data Direction Register bit 3
                 .equ	DDB4	= 4	; Port B Data Direction Register bit 4
                 .equ	DDB5	= 5	; Port B Data Direction Register bit 5
                 .equ	DDB6	= 6	; Port B Data Direction Register bit 6
                 .equ	DDB7	= 7	; Port B Data Direction Register bit 7
                 
                 ; PINB - Port B Input Pins
                 .equ	PINB0	= 0	; Port B Input Pins bit 0
                 .equ	PINB1	= 1	; Port B Input Pins bit 1
                 .equ	PINB2	= 2	; Port B Input Pins bit 2
                 .equ	PINB3	= 3	; Port B Input Pins bit 3
                 .equ	PINB4	= 4	; Port B Input Pins bit 4
                 .equ	PINB5	= 5	; Port B Input Pins bit 5
                 .equ	PINB6	= 6	; Port B Input Pins bit 6
                 .equ	PINB7	= 7	; Port B Input Pins bit 7
                 
                 
                 ; ***** PORTC ************************
                 ; PORTC - Port C Data Register
                 .equ	PORTC0	= 0	; Port C Data Register bit 0
                 .equ	PC0	= 0	; For compatibility
                 .equ	PORTC1	= 1	; Port C Data Register bit 1
                 .equ	PC1	= 1	; For compatibility
                 .equ	PORTC2	= 2	; Port C Data Register bit 2
                 .equ	PC2	= 2	; For compatibility
                 .equ	PORTC3	= 3	; Port C Data Register bit 3
                 .equ	PC3	= 3	; For compatibility
                 .equ	PORTC4	= 4	; Port C Data Register bit 4
                 .equ	PC4	= 4	; For compatibility
                 .equ	PORTC5	= 5	; Port C Data Register bit 5
                 .equ	PC5	= 5	; For compatibility
                 .equ	PORTC6	= 6	; Port C Data Register bit 6
                 .equ	PC6	= 6	; For compatibility
                 .equ	PORTC7	= 7	; Port C Data Register bit 7
                 .equ	PC7	= 7	; For compatibility
                 
                 ; DDRC - Port C Data Direction Register
                 .equ	DDC0	= 0	; Port C Data Direction Register bit 0
                 .equ	DDC1	= 1	; Port C Data Direction Register bit 1
                 .equ	DDC2	= 2	; Port C Data Direction Register bit 2
                 .equ	DDC3	= 3	; Port C Data Direction Register bit 3
                 .equ	DDC4	= 4	; Port C Data Direction Register bit 4
                 .equ	DDC5	= 5	; Port C Data Direction Register bit 5
                 .equ	DDC6	= 6	; Port C Data Direction Register bit 6
                 .equ	DDC7	= 7	; Port C Data Direction Register bit 7
                 
                 ; PINC - Port C Input Pins
                 .equ	PINC0	= 0	; Port C Input Pins bit 0
                 .equ	PINC1	= 1	; Port C Input Pins bit 1
                 .equ	PINC2	= 2	; Port C Input Pins bit 2
                 .equ	PINC3	= 3	; Port C Input Pins bit 3
                 .equ	PINC4	= 4	; Port C Input Pins bit 4
                 .equ	PINC5	= 5	; Port C Input Pins bit 5
                 .equ	PINC6	= 6	; Port C Input Pins bit 6
                 .equ	PINC7	= 7	; Port C Input Pins bit 7
                 
                 
                 ; ***** PORTD ************************
                 ; PORTD - Port D Data Register
                 .equ	PORTD0	= 0	; Port D Data Register bit 0
                 .equ	PD0	= 0	; For compatibility
                 .equ	PORTD1	= 1	; Port D Data Register bit 1
                 .equ	PD1	= 1	; For compatibility
                 .equ	PORTD2	= 2	; Port D Data Register bit 2
                 .equ	PD2	= 2	; For compatibility
                 .equ	PORTD3	= 3	; Port D Data Register bit 3
                 .equ	PD3	= 3	; For compatibility
                 .equ	PORTD4	= 4	; Port D Data Register bit 4
                 .equ	PD4	= 4	; For compatibility
                 .equ	PORTD5	= 5	; Port D Data Register bit 5
                 .equ	PD5	= 5	; For compatibility
                 .equ	PORTD6	= 6	; Port D Data Register bit 6
                 .equ	PD6	= 6	; For compatibility
                 .equ	PORTD7	= 7	; Port D Data Register bit 7
                 .equ	PD7	= 7	; For compatibility
                 
                 ; DDRD - Port D Data Direction Register
                 .equ	DDD0	= 0	; Port D Data Direction Register bit 0
                 .equ	DDD1	= 1	; Port D Data Direction Register bit 1
                 .equ	DDD2	= 2	; Port D Data Direction Register bit 2
                 .equ	DDD3	= 3	; Port D Data Direction Register bit 3
                 .equ	DDD4	= 4	; Port D Data Direction Register bit 4
                 .equ	DDD5	= 5	; Port D Data Direction Register bit 5
                 .equ	DDD6	= 6	; Port D Data Direction Register bit 6
                 .equ	DDD7	= 7	; Port D Data Direction Register bit 7
                 
                 ; PIND - Port D Input Pins
                 .equ	PIND0	= 0	; Port D Input Pins bit 0
                 .equ	PIND1	= 1	; Port D Input Pins bit 1
                 .equ	PIND2	= 2	; Port D Input Pins bit 2
                 .equ	PIND3	= 3	; Port D Input Pins bit 3
                 .equ	PIND4	= 4	; Port D Input Pins bit 4
                 .equ	PIND5	= 5	; Port D Input Pins bit 5
                 .equ	PIND6	= 6	; Port D Input Pins bit 6
                 .equ	PIND7	= 7	; Port D Input Pins bit 7
                 
                 
                 ; ***** CPU **************************
                 ; SREG - Status Register
                 .equ	SREG_C	= 0	; Carry Flag
                 .equ	SREG_Z	= 1	; Zero Flag
                 .equ	SREG_N	= 2	; Negative Flag
                 .equ	SREG_V	= 3	; Two's Complement Overflow Flag
                 .equ	SREG_S	= 4	; Sign Bit
                 .equ	SREG_H	= 5	; Half Carry Flag
                 .equ	SREG_T	= 6	; Bit Copy Storage
                 .equ	SREG_I	= 7	; Global Interrupt Enable
                 
                 ; MCUCR - MCU Control Register
                 ;.equ	ISC00	= 0	; Interrupt Sense Control 0 Bit 0
                 ;.equ	ISC01	= 1	; Interrupt Sense Control 0 Bit 1
                 ;.equ	ISC10	= 2	; Interrupt Sense Control 1 Bit 0
                 ;.equ	ISC11	= 3	; Interrupt Sense Control 1 Bit 1
                 .equ	SM0	= 4	; Sleep Mode Select
                 .equ	SM1	= 5	; Sleep Mode Select
                 .equ	SM2	= 6	; Sleep Mode Select
                 .equ	SE	= 7	; Sleep Enable
                 
                 ; MCUCSR - MCU Control And Status Register
                 .equ	MCUSR	= MCUCSR	; For compatibility
                 .equ	PORF	= 0	; Power-on reset flag
                 .equ	EXTRF	= 1	; External Reset Flag
                 .equ	BORF	= 2	; Brown-out Reset Flag
                 .equ	WDRF	= 3	; Watchdog Reset Flag
                 .equ	JTRF	= 4	; JTAG Reset Flag
                 .equ	JTD	= 7	; JTAG Interface Disable
                 
                 ; OSCCAL - Oscillator Calibration Value
                 .equ	CAL0	= 0	; Oscillator Calibration Value Bit0
                 .equ	CAL1	= 1	; Oscillator Calibration Value Bit1
                 .equ	CAL2	= 2	; Oscillator Calibration Value Bit2
                 .equ	CAL3	= 3	; Oscillator Calibration Value Bit3
                 .equ	CAL4	= 4	; Oscillator Calibration Value Bit4
                 .equ	CAL5	= 5	; Oscillator Calibration Value Bit5
                 .equ	CAL6	= 6	; Oscillator Calibration Value Bit6
                 .equ	CAL7	= 7	; Oscillator Calibration Value Bit7
                 
                 ; SFIOR - Special Function IO Register
                 .equ	PSR10	= 0	; Prescaler Reset Timer/Counter1&0
                 .equ	PSR2	= 1	; Prescaler Reset Timer/Counter2
                 .equ	PUD	= 2	; Pull-up Disable
                 
                 
                 ; ***** BOOT_LOAD ********************
                 ; SPMCR - Store Program Memory Control Register
                 .equ	SPMEN	= 0	; Store Program Memory Enable
                 .equ	PGERS	= 1	; Page Erase
                 .equ	PGWRT	= 2	; Page Write
                 .equ	BLBSET	= 3	; Boot Lock Bit Set
                 .equ	RWWSRE	= 4	; Read While Write secion read enable
                 .equ	ASRE	= RWWSRE	; For compatibility
                 .equ	RWWSB	= 6	; Read While Write Section Busy
                 .equ	ASB	= RWWSB	; For compatibility
                 .equ	SPMIE	= 7	; SPM Interrupt Enable
                 
                 
                 ; ***** TWI **************************
                 ; TWBR - TWI Bit Rate register
                 .equ	TWBR0	= 0	; 
                 .equ	TWBR1	= 1	; 
                 .equ	TWBR2	= 2	; 
                 .equ	TWBR3	= 3	; 
                 .equ	TWBR4	= 4	; 
                 .equ	TWBR5	= 5	; 
                 .equ	TWBR6	= 6	; 
                 .equ	TWBR7	= 7	; 
                 
                 ; TWCR - TWI Control Register
                 .equ	TWIE	= 0	; TWI Interrupt Enable
                 .equ	TWEN	= 2	; TWI Enable Bit
                 .equ	TWWC	= 3	; TWI Write Collition Flag
                 .equ	TWSTO	= 4	; TWI Stop Condition Bit
                 .equ	TWSTA	= 5	; TWI Start Condition Bit
                 .equ	TWEA	= 6	; TWI Enable Acknowledge Bit
                 .equ	TWINT	= 7	; TWI Interrupt Flag
                 
                 ; TWSR - TWI Status Register
                 .equ	TWPS0	= 0	; TWI Prescaler bits
                 .equ	TWPS1	= 1	; TWI Prescaler bits
                 .equ	TWS3	= 3	; TWI Status
                 .equ	TWS4	= 4	; TWI Status
                 .equ	TWS5	= 5	; TWI Status
                 .equ	TWS6	= 6	; TWI Status
                 .equ	TWS7	= 7	; TWI Status
                 
                 ; TWDR - TWI Data register
                 .equ	TWD0	= 0	; TWI Data Register Bit 0
                 .equ	TWD1	= 1	; TWI Data Register Bit 1
                 .equ	TWD2	= 2	; TWI Data Register Bit 2
                 .equ	TWD3	= 3	; TWI Data Register Bit 3
                 .equ	TWD4	= 4	; TWI Data Register Bit 4
                 .equ	TWD5	= 5	; TWI Data Register Bit 5
                 .equ	TWD6	= 6	; TWI Data Register Bit 6
                 .equ	TWD7	= 7	; TWI Data Register Bit 7
                 
                 ; TWAR - TWI (Slave) Address register
                 .equ	TWGCE	= 0	; TWI General Call Recognition Enable Bit
                 .equ	TWA0	= 1	; TWI (Slave) Address register Bit 0
                 .equ	TWA1	= 2	; TWI (Slave) Address register Bit 1
                 .equ	TWA2	= 3	; TWI (Slave) Address register Bit 2
                 .equ	TWA3	= 4	; TWI (Slave) Address register Bit 3
                 .equ	TWA4	= 5	; TWI (Slave) Address register Bit 4
                 .equ	TWA5	= 6	; TWI (Slave) Address register Bit 5
                 .equ	TWA6	= 7	; TWI (Slave) Address register Bit 6
                 
                 
                 
                 ; ***** LOCKSBITS ********************************************************
                 .equ	LB1	= 0	; Lock bit
                 .equ	LB2	= 1	; Lock bit
                 .equ	BLB01	= 2	; Boot Lock bit
                 .equ	BLB02	= 3	; Boot Lock bit
                 .equ	BLB11	= 4	; Boot lock bit
                 .equ	BLB12	= 5	; Boot lock bit
                 
                 
                 ; ***** FUSES ************************************************************
                 ; LOW fuse bits
                 .equ	CKSEL0	= 0	; Select Clock Source
                 .equ	CKSEL1	= 1	; Select Clock Source
                 .equ	CKSEL2	= 2	; Select Clock Source
                 .equ	CKSEL3	= 3	; Select Clock Source
                 .equ	BODEN	= 6	; Brown out detector enable
                 .equ	BODLEVEL	= 7	; Brown out detector trigger level
                 
                 ; HIGH fuse bits
                 .equ	BOOTRST	= 0	; Select Reset Vector
                 .equ	BOOTSZ0	= 1	; Select Boot Size
                 .equ	BOOTSZ1	= 2	; Select Boot Size
                 .equ	EESAVE	= 3	; EEPROM memory is preserved through chip erase
                 .equ	SPIEN	= 5	; Enable Serial programming and Data Downloading
                 .equ	JTAGEN	= 6	; Enable JTAG
                 .equ	OCDEN	= 7	; Enable OCD
                 
                 
                 
                 ; ***** CPU REGISTER DEFINITIONS *****************************************
                 .def	XH	= r27
                 .def	XL	= r26
                 .def	YH	= r29
                 .def	YL	= r28
                 .def	ZH	= r31
                 .def	ZL	= r30
                 
                 
                 
                 ; ***** DATA MEMORY DECLARATIONS *****************************************
                 .equ	FLASHEND	= 0x3fff	; Note: Word address
                 .equ	IOEND	= 0x003f
                 .equ	SRAM_START	= 0x0060
                 .equ	SRAM_SIZE	= 2048
                 .equ	RAMEND	= 0x085f
                 .equ	XRAMEND	= 0x0000
                 .equ	E2END	= 0x03ff
                 .equ	EEPROMEND	= 0x03ff
                 .equ	EEADRBITS	= 10
                 #pragma AVRPART MEMORY PROG_FLASH 32768
                 #pragma AVRPART MEMORY EEPROM 1024
                 #pragma AVRPART MEMORY INT_SRAM SIZE 2048
                 #pragma AVRPART MEMORY INT_SRAM START_ADDR 0x60
                 
                 
                 
                 ; ***** BOOTLOADER DECLARATIONS ******************************************
                 .equ	NRWW_START_ADDR	= 0x3800
                 .equ	NRWW_STOP_ADDR	= 0x3fff
                 .equ	RWW_START_ADDR	= 0x0
                 .equ	RWW_STOP_ADDR	= 0x37ff
                 .equ	PAGESIZE	= 64
                 .equ	FIRSTBOOTSTART	= 0x3f00
                 .equ	SECONDBOOTSTART	= 0x3e00
                 .equ	THIRDBOOTSTART	= 0x3c00
                 .equ	FOURTHBOOTSTART	= 0x3800
                 .equ	SMALLBOOTSTART	= FIRSTBOOTSTART
                 .equ	LARGEBOOTSTART	= FOURTHBOOTSTART
                 
                 
                 
                 ; ***** INTERRUPT VECTORS ************************************************
                 .equ	INT0addr	= 0x0002	; External Interrupt Request 0
                 .equ	INT1addr	= 0x0004	; External Interrupt Request 1
                 .equ	INT2addr	= 0x0006	; External Interrupt Request 2
                 .equ	OC2addr	= 0x0008	; Timer/Counter2 Compare Match
                 .equ	OVF2addr	= 0x000a	; Timer/Counter2 Overflow
                 .equ	ICP1addr	= 0x000c	; Timer/Counter1 Capture Event
                 .equ	OC1Aaddr	= 0x000e	; Timer/Counter1 Compare Match A
                 .equ	OC1Baddr	= 0x0010	; Timer/Counter1 Compare Match B
                 .equ	OVF1addr	= 0x0012	; Timer/Counter1 Overflow
                 .equ	OC0addr	= 0x0014	; Timer/Counter0 Compare Match
                 .equ	OVF0addr	= 0x0016	; Timer/Counter0 Overflow
                 .equ	SPIaddr	= 0x0018	; Serial Transfer Complete
                 .equ	URXCaddr	= 0x001a	; USART, Rx Complete
                 .equ	UDREaddr	= 0x001c	; USART Data Register Empty
                 .equ	UTXCaddr	= 0x001e	; USART, Tx Complete
                 .equ	ADCCaddr	= 0x0020	; ADC Conversion Complete
                 .equ	ERDYaddr	= 0x0022	; EEPROM Ready
                 .equ	ACIaddr	= 0x0024	; Analog Comparator
                 .equ	TWIaddr	= 0x0026	; 2-wire Serial Interface
                 .equ	SPMRaddr	= 0x0028	; Store Program Memory Ready
                 
                 .equ	INT_VECTORS_SIZE	= 42	; size in words
                 
                 #endif  /* _M32ADEF_INC_ */
                 
                 
                  * Simple_Calculator.asm
                  *
                  *  Created: 23/05/2019 11:58:23 ?
                  *   Author: toshiba
                  */ 
                 
000000 940c 0119  jmp start
                 
                 .INCLUDE "LCD_MODULE.inc"
                 
                  * LCD_MODULE.inc
                  *
                  *  Created: 29/11/2018 01:44:27 ?
                  *   Author: toshiba
                  */ 
                  .INCLUDE "Micro_Configration.INC"
                 
                  * IncFile1.inc
                  *
                  *  Created: 29/11/2018 01:28:05 ?
                  *   Author: toshiba
                  */ 
                 
                 
                 
                 .EQU DDRA_IO = DDRA
                 .EQU PINA_INPUT = PINA
                 .EQU PORTA_OUTPUT = PORTA
                 
                 .EQU DDRB_IO =  DDRB
                 .EQU PINB_INPUT = PINB
                 .EQU PORTB_OUTPUT = PORTB
                 
                 .EQU DDRC_IO = DDRC
                 .EQU PINC_INPUT = PINC
                 .EQU PORTC_OUTPUT = PORTC
                 
                 .EQU DDRD_IO = DDRD
                 .EQU PIND_INPUT = PIND
                 
                  .EQU RS = 1
                  .EQU RW = 2
                  .EQU EN = 3
                  ; PORT D
                  .EQU LCD_DATA_DDR_IO = DDRD_IO
                  .EQU LCD_DATA_PORT_OUT = PORTD_OUTPUT
                  .EQU LCD_DATA_PIN_INPUT = PIND_INPUT
                  ;PORT C
                  .EQU LCD_CONTROL_DDR_IO = DDRB_IO
                  .EQU LCD_CONTROL_PORT_OUT = PORTB_OUTPUT
                  .EQU LCD_CONTROL_PIN_INPUT = PINB_INPUT
                  .EQU ENDRAM = $085D  // MAFROOD 5F
                 
                  //intructions
                 
                  .EQU CLEAR = 0X01
                  .EQU CURSOR_ON_BLINK = 0X0E
                  .EQU MATRIX_8BIT = 0X38
                  .EQU set_display_address = 0X80
                 
                 
                  //STACK
                  //.EQU STACKPL = $3D   //STACK POINTER LOW 
                  //.EQU STACKPH = $3E   //STACK POINTER HIGH 
                 
                 
                  //MACROS
                 
                  .MACRO LCD_sendInstruction  ;instruction address(@0)
                 	PUSH R16
                 	LDI R16,@0
                 	
                 	SBI LCD_CONTROL_PORT_OUT,EN
                 	
                 	CBI LCD_CONTROL_PORT_OUT,RS
                 	CBI LCD_CONTROL_PORT_OUT,RW
                 	
                 	OUT LCD_DATA_PORT_OUT , R16
                 
                 	CALL SDelay
                 
                 	CBI LCD_CONTROL_PORT_OUT,EN
                 	CALL Delay_100us
                 	POP R16
                  .ENDMACRO
                  
                 
                  
                 
                  .MACRO LCD_displayChar ;REGISTER (@0)
                 		PUSH R16
                 		MOV	R16,@0
                 		
                 		SBI LCD_CONTROL_PORT_OUT,EN
                 		SBI LCD_CONTROL_PORT_OUT,RS
                 		CBI LCD_CONTROL_PORT_OUT,RW
                 		
                 		OUT LCD_DATA_PORT_OUT , R16
                 		//MOV R31 , R16
                 
                 		CALL SDelay
                 
                 		CBI LCD_CONTROL_PORT_OUT,EN
                 		CALL Delay_100us
                 		POP R16
                 	
                  .ENDMACRO
                 
                  //END MACROS
                 
                   //PROCEDURE
                 
                   LCD_init:   ;void
                 	             
000002 935f      	PUSH R21
000003 ef5f      	LDI R21,0b11111111
000004 bb51      	OUT LCD_DATA_DDR_IO , R21        //make data pins output
                 
                 	
000005 bb57      	OUT LCD_CONTROL_DDR_IO , R21     //make control pins output
                 
000006 98c3      	CBI LCD_CONTROL_PORT_OUT ,EN      //EN=0
                 
000007 930f
000008 e308
000009 9ac3
00000a 98c1
00000b 98c2
00000c bb02
00000d 940e 0033
00000f 98c3
000010 940e 0036
000012 910f      	LCD_sendInstruction MATRIX_8BIT
000013 940e 003e 	CALL Delay_2ms
                 
000015 930f
000016 e00e
000017 9ac3
000018 98c1
000019 98c2
00001a bb02
00001b 940e 0033
00001d 98c3
00001e 940e 0036
000020 910f      	LCD_sendInstruction CURSOR_ON_BLINK
000021 940e 003e 	CALL Delay_2ms
                 
000023 930f
000024 e001
000025 9ac3
000026 98c1
000027 98c2
000028 bb02
000029 940e 0033
00002b 98c3
00002c 940e 0036
00002e 910f      	LCD_sendInstruction CLEAR
00002f 940e 003e 	CALL Delay_2ms
                 
                 	
000031 915f      	POP R21
000032 9508       RET
                 
                  
                  SDelay : 
000033 0000      	nop
000034 0000      	nop
000035 9508      	ret
                 
                 Delay_100us :
000036 931f      	PUSH R17  //momkan nms7ha
000037 e31c      	LDI R17,60
                 	D0:
000038 940e 0033 		CALL SDelay
00003a 951a      		DEC R17
00003b f7e1      		BRNE D0
00003c 911f      	POP R17   //momkan nms7ha
00003d 9508      	ret
                 
                 Delay_2ms :
00003e 931f      	PUSH R17  //momkan nms7ha
00003f e114      	LDI R17,20
                 	D1:
000040 940e 0036 		CALL Delay_100us
000042 951a      		DEC R17
000043 f7e1      		BRNE D1
000044 911f      	POP R17   //momkan nms7ha
000045 9508      	ret
                 
                 
                 .INCLUDE "KEYPAD.inc"
                 
                  * KEYPAD.inc
                  *
                  *  Created: 08/12/2018 12:33:39 ?
                  *   Author: toshiba
                  */ 
                 .EQU KEY_DDR = DDRA
                 .EQU KEY_PORT = PORTA
                 .EQU KEY_PIN = PINA
                 
                 
                 
                 KEY_INIT:
                 	
000046 939f      	push R25
000047 ef90      	LDI R25,0XF0	  // DIRECTION (ROWS(OUT), COLUMNS(INPUT))
000048 bb9a      	OUT KEY_DDR,R25 // DIRECTION
000049 919f      	pop R25
                 
00004a 9508      RET
                 
                 GET_KEY:
00004b 939f      push R25
00004c e09f      	LDI R25,0X0F //ALL ROWS -->0
00004d bb9b      	OUT KEY_PORT,R25
                 
                 	KEY_CHECK:
00004e 0000      		NOP
00004f b399      		IN R25,KEY_PIN //R25 =read 0f columns r25=0x0(columns read)
000050 709f      		ANDI R25,0X0F //mask unused bits
000051 309f      		CPI R25,0x0F		
000052 f7d9      		BRNE KEY_CHECK  //repeat if r25 != 0x0f (y3ni feh al bdaya feh column 2ryalo zero m3 2n mfee4 7aga mt8ota)
                 
                 	wait_key_pressed:
000053 0000      		NOP
000054 b399      		IN R25,KEY_PIN //R25 =read 0f columns r25=0x0(columns read)
000055 709f      		ANDI R25,0X0F  //mask unused bits
000056 309f      		CPI R25,0x0F		
000057 f3d9      		BREQ wait_key_pressed
                 
000058 b399      		IN R25,KEY_PIN //R25 =read 0f columns r25=0x0(columns read)
000059 709f      		ANDI R25,0X0F  //mask unused bits
00005a 309f      		CPI R25,0x0F		
00005b f3b9      		BREQ wait_key_pressed
                 		
                 
                 	                 /*BUTTON IS PRESSED*/
                 		/*Check row0*/
00005c e79f      		LDI R25,0b01111111
00005d bb9b      		OUT KEY_PORT,R25 //row 0-->0
                 
00005e b399      		IN R25,KEY_PIN //R25 =read 0f columns r25=0x0(columns read)
00005f 709f      		ANDI R25,0X0F  //mask unused bits
000060 309f      		CPI R25,0X0F
000061 f401      		BRNE ROW0
                 		//JMP CHECK_ROW1
                 		
                 				//row0 _______________________________________________________________________________________________//
                 				ROW0:
000062 b399      						IN R25,KEY_PIN	//R25 =read 0f columns r25=0x0(columns read)
000063 709f      						ANDI R25,0X0F  //mask unused bits
                 
000064 3097      						CPI R25,0b00000111 /*cmp ll (column reads ) m3 al 7ala al mafrood a 2raya tkon 3lahaw f3ln lw kan al pressed button fe col0*/
000065 f041      						BREQ row0_col0
                 
000066 309b      						CPI R25,0b00001011
000067 f061      						BREQ row0_col1
                 
000068 309d      						CPI R25,0b00001101
000069 f081      						BREQ row0_col2
                 
00006a 309e      						CPI R25,0b00001110
00006b f0a1      						BREQ row0_col3
00006c 940c 0085 						JMP CHECK_ROW1
                 						
                 
                 				/*row0*/
                 				row0_col0:
00006e e391      					LDI R25,'1'
00006f e071      					LDI r23,1
000070 2ff9      					MOV R31,R25
000071 e6ee      					LDI R30,'n'
000072 940c 0102 					JMP SKIP
                 
                 				row0_col1:
000074 e392      					LDI R25,'2'
000075 e072      					LDI r23,2
000076 2ff9      					MOV R31,R25
000077 e6ee      					LDI R30,'n'
000078 940c 0102 					JMP SKIP
                 
                 				row0_col2:
00007a e393      					LDI R25,'3'
00007b e073      					LDI r23,3
00007c 2ff9      					MOV R31,R25
00007d e6ee      					LDI R30,'n'
00007e 940c 0102 					JMP SKIP
                 
                 				row0_col3:
000080 e29b      					LDI R25,'+'//A
000081 2ff9      					MOV R31,R25
000082 e2eb      					LDI R30,'+'
000083 940c 0102 					JMP SKIP
                 
                 		//_________________________________________________________________________________________________________//
                 
                 		/*Check row1*/
                 	    CHECK_ROW1:
                 
000085 eb9f      		LDI R25,0b10111111
000086 bb9b      		OUT KEY_PORT,R25 //row 1-->0
                 
000087 b399      		IN R25,KEY_PIN //R25 =read 0f columns r25=0x0(columns read)
000088 709f      		ANDI R25,0X0F  //mask unused bits
000089 309f      		CPI R25,0X0F
00008a f401      		BRNE ROW1
                 		//JMP CHECK_ROW2
                 				//row1 _______________________________________________________________________________________________//
                 				ROW1:
00008b b399      						IN R25,KEY_PIN	//R25 =read 0f columns r25=0x0(columns read)
00008c 709f      						ANDI R25,0X0F  //mask unused bits
                 
00008d 3097      						CPI R25,0b00000111 /*cmp ll (column reads ) m3 al 7ala al mafrood a 2raya tkon 3lahaw f3ln lw kan al pressed button fe col0*/
00008e f051      						BREQ row1_col0
                 
00008f 309b      						CPI R25,0b00001011
000090 f071      						BREQ row1_col1
                 
000091 309d      						CPI R25,0b00001101
000092 f091      						BREQ row1_col2
                 
000093 309e      						CPI R25,0b00001110
000094 f0b1      						BREQ row1_col3
000095 940c 00b0 						JMP CHECK_ROW2
                 
000097 940c 0102 						JMP SKIP
                 		
                 				/*row1*/
                 				row1_col0:
000099 e394      					LDI R25,'4'
00009a e074      					LDI r23,4
00009b 2ff9      					MOV R31,R25
00009c e6ee      					LDI R30,'n'
00009d 940c 0102 					JMP SKIP
                 
                 				row1_col1:
00009f e395      					LDI R25,'5'
0000a0 e075      					LDI r23,5
0000a1 2ff9      					MOV R31,R25
0000a2 e6ee      					LDI R30,'n'
0000a3 940c 0102 					JMP SKIP
                 
                 				row1_col2:
0000a5 e396      					LDI R25,'6'
0000a6 e076      					LDI r23,6
0000a7 2ff9      					MOV R31,R25
0000a8 e6ee      					LDI R30,'n'
0000a9 940c 0102 					JMP SKIP
                 
                 				row1_col3:
0000ab e29d      					LDI R25,'-'    //B
0000ac 2ff9      					MOV R31,R25
0000ad e2ed      					LDI R30,'-'
0000ae 940c 0102 					JMP SKIP
                 				//_________________________________________________________________________________________________________//
                 
                 
                 		/*Check row2*/
                 	    CHECK_ROW2:
0000b0 ed9f      		LDI R25,0b11011111
0000b1 bb9b      		OUT KEY_PORT,R25 //row 2-->0
                 
0000b2 b399      		IN R25,KEY_PIN //R25 =read 0f columns r25=0x0(columns read)
0000b3 709f      		ANDI R25,0X0F  //mask unused bits
0000b4 309f      		CPI R25,0X0F
0000b5 f401      		BRNE ROW2
                 		//JMP CHECK_ROW3
                 
                 				//row2 _______________________________________________________________________________________________//
                 				ROW2:
0000b6 b399      						IN R25,KEY_PIN	//R25 =read 0f columns r25=0x0(columns read)
0000b7 709f      						ANDI R25,0X0F  //mask unused bits
                 
0000b8 3097      						CPI R25,0b00000111 /*cmp ll (column reads ) m3 al 7ala al mafrood a 2raya tkon 3lahaw f3ln lw kan al pressed button fe col0*/
0000b9 f051      						BREQ row2_col0
                 
0000ba 309b      						CPI R25,0b00001011
0000bb f071      						BREQ row2_col1
                 
0000bc 309d      						CPI R25,0b00001101
0000bd f091      						BREQ row2_col2
                 
0000be 309e      						CPI R25,0b00001110
0000bf f0b1      						BREQ row2_col3
0000c0 940c 00db 						JMP CHECK_ROW3
0000c2 940c 0102 						JMP SKIP
                 
                 		
                 				/*row2*/
                 				row2_col0:
0000c4 e397      					LDI R25,'7'
0000c5 e077      					LDI r23,7
0000c6 2ff9      					MOV R31,R25
0000c7 e6ee      					LDI R30,'n'
0000c8 940c 0102 					JMP SKIP
                 
                 				row2_col1:
0000ca e398      					LDI R25,'8'
0000cb e078      					LDI r23,8
0000cc 2ff9      					MOV R31,R25
0000cd e6ee      					LDI R30,'n'
0000ce 940c 0102 					JMP SKIP
                 
                 				row2_col2:
0000d0 e399      					LDI R25,'9'
0000d1 e079      					LDI r23,9
0000d2 2ff9      					MOV R31,R25
0000d3 e6ee      					LDI R30,'n'
0000d4 940c 0102 					JMP SKIP
                 
                 				row2_col3:
0000d6 e59e      					LDI R25,'^'//C
0000d7 2ff9      					MOV R31,R25
0000d8 e5ee      					LDI R30,'^'
0000d9 940c 0102 					JMP SKIP
                 
                 				//______________________________________________________________________________________________________//
                 
                 		/*Check row3*/
                 		CHECK_ROW3:
0000db ee9f      		LDI R25,0b11101111
0000dc bb9b      		OUT KEY_PORT,R25 //row 3-->0
                 
0000dd b399      		IN R25,KEY_PIN //R25 =read 0f columns r25=0x0(columns read)
0000de 709f      		ANDI R25,0X0F  //mask unused bits
0000df 309f      		CPI R25,0X0F
0000e0 f401      		BRNE ROW3
                 		//JMP skip
                 				//row3____________________________________________________________________________________________//
                 			
                 
                 				ROW3:
0000e1 b399      						IN R25,KEY_PIN	//R25 =read 0f columns r25=0x0(columns read)
0000e2 709f      						ANDI R25,0X0F  //mask unused bits
                 
0000e3 3097      						CPI R25,0b00000111 /*cmp ll (column reads ) m3 al 7ala al mafrood a 2raya tkon 3lahaw f3ln lw kan al pressed button fe col0*/
0000e4 f041      						BREQ row3_col0
                 
0000e5 309b      						CPI R25,0b00001011
0000e6 f059      						BREQ row3_col1
                 
0000e7 309d      						CPI R25,0b00001101
0000e8 f079      						BREQ row3_col2
                 
0000e9 309e      						CPI R25,0b00001110
0000ea f091      						BREQ row3_col3
                 
0000eb 940c 0102 						JMP SKIP
                 
                 				/*row3*/
                 				row3_col0:
0000ed e29a      					LDI R25,'*'
0000ee 2ff9      					MOV R31,R25
0000ef e2ea      					LDI R30,'*'
0000f0 940c 0102 					JMP SKIP
                 
                 				row3_col1:
0000f2 e390      					LDI R25,'0'
0000f3 e070      					LDI r23,0
0000f4 2ff9      					MOV R31,R25
0000f5 e6ee      					LDI R30,'n'
0000f6 940c 0102 					JMP SKIP
                 
                 				row3_col2:
0000f8 e39d      					LDI R25,'=' //#
0000f9 2ff9      					MOV R31,R25
0000fa e3ed      					LDI R30,'='
0000fb 940c 0102 					JMP SKIP
                 
                 				row3_col3:
0000fd e494      					LDI R25,'D'
0000fe 2ff9      					MOV R31,R25
0000ff e4e4      					LDI R30,'D'
                 
                 	/*CLR first1
                 	CLR first2			
                 	CLR second1
                 	CLR second2
                 	CLR total1
                 	CLR total2
                 	CLR total3
                 	CLR total4
                 	LCD_sendInstruction CLEAR
                 					LCD_sendInstruction set_display_address
000100 940c 0102 		*/			JMP SKIP
                 		
                 
                 
                 
                 				/*____________________________________________________________________________________________________________________________________*/
                 		          /*i know the row & the column*/ /*detect char*/
                 
                 		
                 		                   /* get the char*/
                 
                 
                 		SKIP:
000102 919f      		pop R25
                 .INCLUDE "CALC.inc"
000103 9508      
                  * CALC.inc
                  *
                  *  Created: 20/12/2018 08:35:53 ?
                  *   Author: toshiba
                  */ 
                  /*
                  name : MULT16x10_ADDr23 
                  parameter : @0-->nu*m1(low) ,@1--> num1(high)
                  function :  (first2:first1)*10+(number readed from lcd(stored in r23))
                  return : value in (first2:first1)
                  */
                  .MACRO MULT16x10_ADDr23 
                 
                 	push r17
                 	PUSH R2
                 	PUSH R3
                 	push r16
                 			ldi r16,0
                 
                 			LDI r17,10
                 	        MUL @0,r17
                 			            
                 		    MOVW R3:R2,R1:R0 
                 
                 			MUL @1,r17          
                 			ADD R3,R0          
                 			
                 			movw @1:@0, R3:R2
                 
                 			ADD @0,r23         
                 			ADC @1,r16        
                 
                 			
                 	pop r17
                 	POP R2
                 	POP R3
                 	pop r16
                 
                  .ENDMACRO
                  /*---------------------------------------------------------------------------------------------------*/
                   /*
                  name : MULT16x16 
                  parameter : @0-->num1(low) ,@1 -->num1(high), @2-->num2(low) ,@3-->num2(high), @4-->total1 ,@5 -->total2, @6-->total3 ,@7-->total4
                  function :  (first2:first1)*(second2:second1)
                  return : value in (total4:total3:total2:total1)
                  */
                  .MACRO MULT16x16 
                 	
                 		CLR ZERO             
                         MUL @1,@3            
                         MOVW @7:@6,R1:R0 
                 
                 		
                         MUL @0,@2           
                 	  
                 
                         MOVW @5:@4,R1:R0 
                 
                 		
                         MUL @1,@2            
                 		
                 
                         ADD @5,R0         
                         ADC @6,R1         
                         ADC @7,R2       
                 
                 		
                         MUL @3,@0           
                 
                         ADD @5,R0          
                         ADC @6,R1          
                         ADC @7,R2       
                 
                 		MOVW @1:@0,@5:@4
                 
                 
                  .ENDMACRO
                 
                  /*-------------------------------------------------------------------------------------------------------------------*/
                  
                   /*
                  name : ADD16x16_2 
                  parameter : @0-->num1(low) ,@1 -->num1(high), @2-->num2(low) ,@3-->num2(high), @4-->total1 ,@5 -->total2, @6-->total3 ,@7-->total4
                  function :  (first2:first1) + (second2:second1)
                  return : value in (total4:total3:total2:total1)
                  */
                  .MACRO ADD16x16_2 
                 		
                 		CLR ZERO
                 		
                 		movw @5:@4,@1:@0
                 		
                 
                 		ADD @4,@2
                 		ADC @5,@3
                 		ADC @6,ZERO
                 		ADC @7,ZERO
                 
                 		MOVW @1:@0,@5:@4
                 		
                 		
                  .ENDMACRO
                  /*-----------------------------------------------------------------------------------------------------------------------*/
                   /*
                  name : ADD16x16
                  parameter : @0-->num1(low) ,@1 -->num1(high), @2-->num2(low) ,@3-->num2(high), @4-->total1 ,@5 -->total2, @6-->total3 ,@7-->total4
                  function :  call ADD_FIRSTNEG (which make addition with all statues)
                  return : value in (total4:total3:total2:total1)
                  */
                  .MACRO ADD16x16 
                 		
                 		CLR ZERO
                 		ADD_FIRSTNEG @0,@1,@2,@3,@4,@5,@6,@7		
                 		
                 
                  .ENDMACRO
                  
                  /*---------------------------------------------------------------------------------------------------------------------*/
                  /*
                  name : ADD_FIRSTNEG
                  parameter : @0-->num1(low) ,@1 -->num1(high), @2-->num2(low) ,@3-->num2(high), @4-->total1 ,@5 -->total2, @6-->total3 ,@7-->total4
                  function :  if first num is neg --> neg(first2:first1) then (first2:first1)-(second2:second1)---> make neg(total4:total3:total2:total1)
                 			else
                 			(first2:first1)+(second2:second1)
                  return : value in (total4:total3:total2:total1)
                  */
                  .MACRO ADD_FIRSTNEG 
                 
                 	PUSH R24
                 	CLR ZERO
                 	
                 		tst @1
                 	BREQ end_negative_2_
                 	BRPL end_negative_2_
                 		com @1
                 		com @0
                 		LDI R24,1
                 		ADD @0,R24
                 		ADC @1,ZERO
                 		SUB16x16 @0,@1,@2,@3,@4,@5,@6,@7
                 		/*get 2's complement of result*/
                 		com @4
                 		com @5
                 		com @6
                 		com @7
                 		ldi r24,1
                 		add @4,r24
                 		adc @5,ZERO
                 		adc @6,ZERO
                 		adc @7,ZERO
                 		/*-------------*/
                 		JMP end_negative_test_1
                 	end_negative_2_:
                 		ADD16x16_2 @0,@1,@2,@3,@4,@5,@6,@7
                 		JMP end_negative_test_1
                 		/*--------------------------*/
                 		
                 
                 	end_negative_test_1:
                 	POP R24
                 
                  .ENDMACRO
                  /*---------------------------------------------------------------------------------------------------------------------*/
                  /*
                  name : MULT_FIRSTNEG
                  parameter : @0-->num1(low) ,@1 -->num1(high), @2-->num2(low) ,@3-->num2(high), @4-->total1 ,@5 -->total2, @6-->total3 ,@7-->total4
                 
                  function :  if first num is neg --> neg(first2:first1) then (first2:first1)*(second2:second1)---> make neg(total4:total3:total2:total1)
                 			else
                 			(first2:first1)*(second2:second1)
                 
                  return : value in (total4:total3:total2:total1)
                  */
                 
                  .MACRO MULT_FIRSTNEG 
                 
                 	PUSH R24
                 	CLR ZERO
                 	
                 		tst @1
                 	BREQ MUL_3ADYA
                 	BRPL MUL_3ADYA
                 		com @1
                 		com @0
                 		LDI R24,1
                 		ADD @0,R24
                 		ADC @1,ZERO
                 		MULT16x16 @0,@1,@2,@3,@4,@5,@6,@7
                 		/*get 2's complement of result*/
                 		com @4
                 		com @5
                 		com @6
                 		com @7
                 		ldi r24,1
                 		add @4,r24
                 		adc @5,ZERO
                 		adc @6,ZERO
                 		adc @7,ZERO
                 
                 		MOVW @1:@0,@5:@4
                 		/*-------------*/
                 		JMP end_negative_t
                 	MUL_3ADYA:
                 		 MULT16x16 @0,@1,@2,@3,@4,@5,@6,@7
                 		JMP end_negative_t
                 		/*--------------------------*/
                 		
                 
                 	end_negative_t:
                 	POP R24
                 
                  .ENDMACRO
                  /*---------------------------------------------------------------------------------------------------------------------*/
                 
                   /*
                  name : SUB16x16
                  parameter : @0-->num1(low) ,@1 -->num1(high), @2-->num2(low) ,@3-->num2(high), @4-->total1 ,@5 -->total2, @6-->total3 ,@7-->total4
                  function :  (first2:first1)-(second2:second1)
                  return : value in (total4:total3:total2:total1)
                  */
                 
                  .MACRO SUB16x16 
                 
                 		CLR ZERO
                 		movw @5:@4,@1:@0
                 		
                 		SUB @4,@2
                 		SBC @5,@3
                 		SBC @6,ZERO
                 		SBC @7,ZERO
                     
                 		MOVW @1:@0,@5:@4
                  .ENDMACRO
                 
                   /*---------------------------------------------------------------------------------------------------------------------*/
                 
                   /*
                  name : power16x16
                  parameter : @0-->num1(low) ,@1 -->num1(high), @2-->num2(low) ,@3-->num2(high), @4-->total1 ,@5 -->total2, @6-->total3 ,@7-->total4
                  function :  get power --> (first2:first1)^(second2:second1)  
                  return : value in (total4:total3:total2:total1)
                  */
                 
                  .MACRO power16x16 
                  
                 	CLR ZERO
                 	push r24
                 	 /* check zero */
                 
                 	check_two @2,@3
                 	BRNE check_one
                 		/*power is zero*/
                 	ldi r24,1
                 	mov @4,r24
                 
                 	ldi r24,0
                 	mov @5,r24
                 
                 	ldi r24,0
                 	mov @6,r24
                 
                 	ldi r24,0
                 	mov @7,r24
                 
                 	MOVW @1:@0,@5:@4
                 
                 	jmp power_end
                 
                 		/* check one */
                 	check_one:
                 	cpi second2,0
                 	brne power_code
                 
                 	cpi second1,1
                 	brne power_code
                 
                 		ldi @2,1
                 		ldi @3,0
                 		MULT_FIRSTNEG @0,@1,@2,@3,@4,@5,@6,@7
                 		jmp power_end
                 		/*original power code*/
                 
                 	power_code:
                 		movw @5:@4 , @1:@0
                 
                 		ldi r24,1
                 		sub @2,r24
                 		sbc @3,ZERO
                 
                 	//movw c1:c,@3:@2
                 	mov c,@2
                 	mov c1,@3
                 	movw @3:@2,@1:@0 //second hold the base
                 
                 loop:
                 
                 	check_two c,c1
                 	BREQ power_end
                      
                 	 movw @1:@0,@5:@4
                       
                 	MULT16x16 @0,@1,@2,@3,@4,@5,@6,@7
                 
                 	ldi r24,1
                 	sub c,r24
                 	sbc c1,ZERO
                 	jmp loop
                 
                 
                 
                 		/*end original power code*/
                 	power_end:
                 
                 	pop r24
                  .ENDMACRO
                 
                  /*---------------------------------------------------------------------------------------------------------------------*/
                 
                   /*
                  name : check_two
                  parameter : @0-->num1(low) ,@1 -->num1(high)
                  function :  check if number is zero or not  
                  no return (just affect flags)
                  */
                  .MACRO check_two 
                 	
                 	tst @0
                 	brne NotEqual
                 
                 	tst @1
                 	brne NotEqual
                 
                 	
                 	NotEqual:
                 .ENDMACRO
                 .INCLUDE "convert_to_string.inc"
                 
                  * convert_to_string.inc
                  *
                  *  Created: 23/12/2018 06:32:20 ?
                  *   Author: toshiba
                  */ 
                 
                 
                 
                 .MACRO DIV3210 /*  @0-->total1 ,@1 -->total2 , @2-->total3 ,@3-->total4   */
                 
                 	PUSH R24
                 		
                 	DIV3216:
                 			CLR ZERO
                 			
                 			LDI R24,33         
                 			MOV C,r24
                 			SUB REM1,REM1    
                 			CLR REM2         
                 			CLR REM3          
                 			CLR REM4          
                 	LOOP:	ROL @0          
                 			ROL @1        
                 			ROL @2          
                 			ROL @3         
                 			DEC C             
                 			BREQ DONE        
                 			ROL REM1          
                 			ROL REM2         
                 			ROL REM3         
                 			ROL REM4         
                 			LDI R24,10
                 			SUB REM1,R24       
                 			SBC REM2,ZERO      
                 			SBC REM3,ZERO    
                 			SBC REM4,ZERO     
                 			BRCC SKIP       
                 			LDI R24,10
                 			ADD REM1,R24     
                 			ADC REM2,ZERO      
                 			ADC REM3,ZERO    
                 			ADC REM4,ZERO    
                 			CLC               
                 			RJMP LOOP        
                 	SKIP:	SEC               
                 			RJMP LOOP
                 	DONE:
                 	
                 	POP R24
                 
                 .ENDMACRO
                 
                    /*-----------------------------------------------------------------------------------------------------------------*/
                 
                 .MACRO DIV1610 /*  @0-->total1 ,@1 -->total2  */
                 
                 	PUSH R24
                 	CLR ZERO
                 
                    DIV1616:
                        LDI R24,17
                         MOV C,R24          ;Load bit counter
                         SUB REM1,REM1     ;Clear Remainder and Carry
                         CLR REM2          ;
                 LOO:   ROL @0          ;Shift the answer to the left
                         ROL @1          ;
                         DEC C             ;Decrement Counter
                         BREQ DON        ;Exit if sixteen bits done
                         ROL REM1          ;Shift remainder to the left
                         ROL REM2          ;
                 		LDI R24,10
                         SUB REM1,R24       ;Try to subtract divisor from remainder
                         SBC REM2,ZERO
                          BRCC SKI        ;If the result was negative then
                 		 LDI R24,10
                         ADD REM1,R24       ;reverse the subtraction to try again
                         ADC REM2,ZERO       ;
                         CLC               ;Clear Carry Flag so zero shifted into A 
                          RJMP LOO        ;Loop Back
                 SKI:   SEC               ;Set Carry Flag to be shifted into A
                          RJMP LOO
                 DON:
                 
                 POP R24
                 
                 .ENDMACRO
                 
                    /*------------------------------------------------------------------------------------------------------------------*/
                 .MACRO convert_display /*  @0-->total1 ,@1 -->total2 , @2-->total3 ,@3-->total4   */
                 
                 	push R24
                 	LDI R24,1
                 	MOV neg_check,R24
                 	
                 	ldi R24,'\0' // M4 3ARFa lah 7to hna
                 	st Y+,R24
                 
                 	check @0,@1,@2,@3
                 	BRNE code
                 		
                 		ldi r24,'0'
                 		st Y+,r24
                 
                 		jmp display_part
                 
                 	code:
                 	/*tst @3
                 
                 	brpl not_neg 
                 		clr neg_check
                 		MULT32xminus1 @0,@1,@2,@3
                 */
                 	
                 	negative_test @0,@1,@2,@3
                 	not_neg:
                 	while_not_zero:
                 
                 		check @0,@1,@2,@3
                 		BREQ jmp_end
                 		BRNE loop
                 
                 	jmp_end:
                 		jmp end_while
                 
                 	loop:
                 
                 		DIV3210 @0,@1,@2,@3
                 		ldi r24,'0'
                 		add rem1,r24
                 		st Y+,rem1
                 		jmp while_not_zero
                 			
                 
                 	
                 
                 	end_while:
                 
                 		LDI R24,1
                 		CP neg_check,R24
                 		BREQ display_part //if neg_check =0 branch to dispay
                 
                 			 //negative if neg_check = 1
                 			ldi R24,'-'
                 			st Y+,R24
                 
                 
                 	display_part :
                 
                 		CALL DISPLAY_RES
                 
                 
                 	POP R24
                 
                 .ENDMACRO
                 
                 
                     /*-----------------------------------------------------------------------------------------------------------*/
                 
                 	/*-----------------------------------------------------------------------------------------------------------------*/
                 
                 .MACRO convert_display2 /*  @0-->total1 ,@1 -->total2 , @2-->total3 ,@3-->total4   */
                 
                 	CLR ZERO
                 	push R24
                 	LDI R24,1
                 	MOV neg_check,R24
                 	
                 	ldi R24,'\0' // M4 3ARFa lah 7to hna
                 	st Y+,R24
                 
                 	check_two @0,@1
                 	BRNE code
                 		
                 		ldi r24,'0'
                 		st Y+,r24
                 
                 		jmp display_part
                 
                 	code:
                 	/*tst @1
                 
                 	brpl not_neg 
                 		clr neg_check
                 		MULT32xminus1_2 @0,@1
                 */
                 	negative_test2 @0,@1
                 
                 	not_neg:
                 	while_not_zero:
                 
                 		check_two @0,@1
                 		BREQ jmp_end
                 		BRNE loop
                 
                 	jmp_end:
                 		jmp end_while
                 
                 	loop:
                 
                 		DIV1610 @0,@1
                 		ldi r24,'0'
                 		add rem1,r24
                 		st Y+,rem1
                 		jmp while_not_zero
                 			
                 
                 	
                 
                 	end_while:
                 
                 		LDI R24,1
                 		CP neg_check,R24
                 		BREQ display_part //if neg_check =0 branch to dispay
                 
                 			 //negative if neg_check = 1
                 			ldi R24,'-'
                 			st Y+,R24
                 
                 
                 	display_part :
                 
                 		CALL DISPLAY_RES
                 
                 
                 	POP R24
                 
                 .ENDMACRO
                 
                 
                     /*-----------------------------------------------------------------------------------------------------------*/
                 
                 	
                 
                 
                 .MACRO check /*  @0-->total1 ,@1 -->total2 , @2-->total3 ,@3-->total4   */ /*ht7t al natg fe al ans (h4eel 7tt al n2l al fe a 2wal)*/
                 	
                 	tst @0
                 	brne NotEqual
                 
                 	tst @1
                 	brne NotEqual
                 
                 	tst @2
                 	brne NotEqual
                 
                 	tst @3
                 	brne NotEqual
                 
                 
                 	NotEqual:
                 .ENDMACRO
                 
                 		 /*-----------------------------------------------------------------------------------------------------*/
                 
                 .MACRO negative_test /*  @0-->total1 ,@1 -->total2 , @2-->total3 ,@3-->total4   */
                 	PUSH R24
                 	CLR ZERO
                 	tst @3
                 	BREQ total4_iszero
                 	BRPL end_negative
                 		com @3
                 		com @2
                 		com @1
                 		com @0
                 		LDI R24,1
                 		ADD @0,R24
                 		ADC @1,ZERO
                 		ADC @2,ZERO
                 		ADC @3,ZERO
                 		CLR ZERO
                 		MOV neg_check,ZERO
                 		JMP end_negative_test
                 	end_negative:
                 		JMP end_negative_test
                 
                 		/*-------------------------------*/
                 	total4_iszero:
                 	tst @2
                 	BREQ total3_iszero
                 	BRPL end_negative1
                 		com @2
                 		com @1
                 		com @0
                 		LDI R24,1
                 		ADD @0,R24
                 		ADC @1,ZERO
                 		ADC @2,ZERO
                 		ADC @3,ZERO
                 		CLR ZERO
                 		MOV neg_check,ZERO
                 		JMP end_negative_test
                 	end_negative1:
                 		JMP end_negative_test
                 		/*--------------------------*/
                 		total3_iszero:
                 		tst @1
                 	BREQ total2_iszero
                 	BRPL end_negative2
                 		com @1
                 		com @0
                 		LDI R24,1
                 		ADD @0,R24
                 		ADC @1,ZERO
                 		ADC @2,ZERO
                 		ADC @3,ZERO
                 		CLR ZERO
                 		MOV neg_check,ZERO
                 		JMP end_negative_test
                 	end_negative2:
                 		JMP end_negative_test
                 		/*--------------------------*/
                 		total2_iszero:
                 		tst @0
                 	BREQ total1_iszero
                 	BRPL end_negative3
                 		com @0
                 		LDI R24,1
                 		ADD @0,R24
                 		ADC @1,ZERO
                 		ADC @2,ZERO
                 		ADC @3,ZERO
                 		CLR ZERO
                 		MOV neg_check,ZERO
                 		JMP end_negative_test
                 	end_negative3:
                 		JMP end_negative_test
                 		/*--------------------------*/
                 	total1_iszero:
                 	end_negative_test:
                 	POP R24
                 .ENDMACRO
                 		 /*------------------------------------------------------------------------------------------------------*/
                  /*-----------------------------------------------------------------------------------------------------*/
                 
                 .MACRO negative_test2 /*  @0-->total1 ,@1 -->total2   */
                 	PUSH R24
                 	CLR ZERO
                 	
                 		tst @1
                 	BREQ t2_iszero
                 	BRPL end_negative_2
                 		com @1
                 		com @0
                 		LDI R24,1
                 		ADD @0,R24
                 		ADC @1,ZERO
                 		CLR ZERO
                 		MOV neg_check,ZERO //m4 hn7tagha fe al add de ll 3rd bs 
                 		JMP end_negative_test_
                 	end_negative_2:
                 		JMP end_negative_test_
                 		/*--------------------------*/
                 		t2_iszero:
                 		tst @0
                 	BREQ t1_iszero
                 	BRPL end_negative_1
                 		com @0
                 		LDI R24,1
                 		ADD @0,R24
                 		ADC @1,ZERO
                 		CLR ZERO
                 		MOV neg_check,ZERO
                 		JMP end_negative_test_
                 	end_negative_1:
                 		JMP end_negative_test_
                 		/*--------------------------*/
                 	t1_iszero:
                 	end_negative_test_:
                 	POP R24
                 .ENDMACRO
                 		 /*------------------------------------------------------------------------------------------------------*/
                 
                 
                 .MACRO MULT32xminus1 /*  @0-->total1 ,@1 -->total2 , @2-->total3 ,@3-->total4   *//* ht7t al natg fe al ans (h4eel 7tt al n2l al fe a 2wal)*/
                 	PUSH R24
                 	CLR ZERO
                 
                 	com @0
                 	com @1
                 	com @2
                 	com @3
                 
                 	LDI R24,1
                 	ADD @0,R24
                 	ADC @1,ZERO
                 	ADC @2,ZERO
                 	ADC @3,ZERO
                 
                 	POP R24
                 .ENDMACRO
                 
                 /*-----------------------------------------------------------------------------------------------------*/
                 .MACRO MULT32xminus1_2 /*  @0-->first1 ,@1 -->first2*/
                 
                 	PUSH R24
                 	CLR ZERO
                 
                 	com @0
                 	com @1
                 	
                 
                 	LDI R24,1
                 	ADD @0,R24
                 	ADC @1,ZERO
                 
                 .ENDMACRO
                 
                  /*-----------------------------------------------------------------------------------------------------*/
                 DISPLAY_RES:
                 
000104 95ca      	DEC YL
000105 8188      	Ld R24,Y
                 	
000106 3080      	CPI R24,'\0'
000107 f071      	BREQ RETURN
                 
000108 930f
000109 2f08
00010a 9ac3
00010b 9ac1
00010c 98c2
00010d bb02
00010e 940e 0033
000110 98c3
000111 940e 0036
000113 910f      		LCD_displayChar R24
000114 940c 0104 		jmp DISPLAY_RES
                 
                 	
                 	RETURN:
                 
000116 e6c0      	LDI YL,LOW(final_ans)
000117 e0d0      	LDI YH,HIGH(final_ans)
                 
                 .include "def_reg.inc"
000118 9508      
                  * def_reg.inc
                  *
                  *  Created: 26/12/2018 10:48:16 ?
                  *   Author: toshiba
                  */ 
                 
                  .DEF first1 = R18
                 .DEF first2 = R19
                 
                 .DEF op = R22
                 
                 .DEF second1 = R20
                 .DEF second2 = R21
                 
                 .DEF total1 = R12
                 .DEF total2 = R13
                 .DEF total3 = R14
                 .DEF total4 = R15
                 
                 
                 //.DEF count = R2
                 
                 //R31 : 2RAYT AL KEYPAD
                 //R30:RKM WLA L2
                 //r23 4yla al rkm
                 
                 /* itoa */
                 .DEF ZERO=R2
                 
                 .DEF neg_check = R11
                 
                 .DEF REM1 = R7            ;To hold first-byte of remainder
                 .DEF REM2 = R8            ;To hold second-byte of remainder
                 .DEF REM3 = R9            ;To hold third-byte of remainder
                 .DEF REM4 = R10            ;To hold fourth-byte of remainder
                 
                 .DEF    C = R5           ;Bit Counter
                 
                 
                         /*----------------------------------------------------------------------*/
                 .dseg
000060           final_ans: .byte 13
                 
                        /*------------------------------------------------------------------------*/
                 .cseg
                 start:
000119 934f      	PUSH R20
00011a e048      	LDI R20,HIGH(ENDRAM)
00011b bf4e      	OUT SPH,R20                    
                 
00011c e54d      	LDI R20,LOW(ENDRAM)
00011d bf4d      	OUT SPL,R20
00011e 914f      	POP R20
                 
00011f e6c0      	LDI YL,LOW(final_ans)
000120 e0d0      	LDI YH,HIGH(final_ans)
                 
000121 940e 0123 	CALL main
                 
                 
                 /*____________________________________________________________________________________*/
                 
                 main:  
                 	
                 	
000123 940e 0128 	CALL void_SETUP
000125 940e 0135 	CALL void_LOOP
                 		
                 	
000127 9508      RET //END MAIN
                 
                 /*________________________VOID SETUP____________________________________________________________*/
                 
                 void_SETUP:
                 
                 	
                 	//LDI count,1
000128 e020      	LDI first1,0
000129 e030      	LDI first2,0
                 
00012a e040      	LDI second1,0
00012b e050      	LDI second2,0
                 
00012c 24cc      	CLR total1
00012d 24dd      	CLR total2
00012e 24ee      	CLR total3
00012f 24ff      	CLR total4
                 
000130 940e 0002 	CALL LCD_init
000132 940e 0046 	CALL KEY_INIT
                 	
000134 9508      RET
                 
                 /*_________________________VOID LOOP___________________________________________________________*/
                 
                 void_LOOP:
                 	
                 
                 	first_num:
000135 940e 004b 		CALL GET_KEY //r31 feha al key_pressed , r30 ='n' if num presses otherwise r30=operation
000137 930f
000138 2f0f
000139 9ac3
00013a 9ac1
00013b 98c2
00013c bb02
00013d 940e 0033
00013f 98c3
000140 940e 0036
000142 910f      		LCD_displayChar r31
000143 36ee      		CPI R30,'n'
000144 f499      		BRNE IS_OP
000145 931f
000146 922f
000147 923f
000148 930f
000149 e000
00014a e01a
00014b 9f21
00014c 0110
00014d 9f31
00014e 0c30
00014f 0191
000150 0f27
000151 1f30
000152 911f
000153 902f
000154 903f
000155 910f      			MULT16x10_ADDr23 first1,first2
000156 940c 0135 			jmp first_num
                 
                 	IS_OP:
000158 2f6f      		mov op,r31	
000159 2744      		CLR second1
00015a 2755      		CLR second2
00015b 24cc      		CLR total1
00015c 24dd      		CLR total2
00015d 24ee      		CLR total3
00015e 24ff      		CLR total4
                 
                 			second_num:
00015f 940e 004b 				CALL GET_KEY //r31 feha al key_pressed , r30 ='n' if num presses otherwise r30=operation
000161 930f
000162 2f0f
000163 9ac3
000164 9ac1
000165 98c2
000166 bb02
000167 940e 0033
000169 98c3
00016a 940e 0036
00016c 910f      				LCD_displayChar r31
00016d 36ee      				CPI R30,'n'
00016e f499      				BRNE equal//htt3dl
00016f 931f
000170 922f
000171 923f
000172 930f
000173 e000
000174 e01a
000175 9f41
000176 0110
000177 9f51
000178 0c30
000179 01a1
00017a 0f47
00017b 1f50
00017c 911f
00017d 902f
00017e 903f
00017f 910f      					MULT16x10_ADDr23 second1,second2
000180 940c 015f 					jmp second_num
                 					
                 
                 	equal:
                 		/*CPI OP,'+'
                 		BRNE mult_check
                 			jmp addition
                 		mult_check:
                 
                 			jmp multiplication
                 			*/
000182 326b      		CPI OP,'+'
000183 f411      		BRNE check_mult
000184 940c 0194 		JMP addition
                 check_mult:
000186 326a      		CPI OP,'*'
000187 f411      		BRNE check_sub
000188 940c 02e8 		jmp multiplication
                 check_sub:
00018a 326d      		CPI OP,'-'
00018b f411      		BRNE check_power
00018c 940c 03e1 		jmp subtraction
                 check_power:
00018e 356e      		CPI OP,'^'
00018f f411      		BRNE check_others
000190 940c 04ac 		jmp power
                 
                 check_others:
000192 940c 05e0 		jmp others
                 
                 		addition:
000194 2422
000195 938f
000196 2422
000197 2333
000198 f0c1
000199 f4ba
00019a 9530
00019b 9520
00019c e081
00019d 0f28
00019e 1d32
00019f 2422
0001a0 0169
0001a1 1ac4
0001a2 0ad5
0001a3 08e2
0001a4 08f2
0001a5 0196
0001a6 94c0
0001a7 94d0
0001a8 94e0
0001a9 94f0
0001aa e081
0001ab 0ec8
0001ac 1cd2
0001ad 1ce2
0001ae 1cf2
0001af 940c 01ba
0001b1 2422
0001b2 0169
0001b3 0ec4
0001b4 1ed5
0001b5 1ce2
0001b6 1cf2
0001b7 0196
0001b8 940c 01ba
0001ba 918f      			ADD16x16 first1,first2,second1,second2,total1,total2,total3,total4
                 			//MOVW total2:total1 , first2:first1
                 
                 				/*h3rd first1,first2 (clear lcd -->display result)*/
                 					
0001bb 938f
0001bc e081
0001bd 2eb8
0001be e080
0001bf 9389
0001c0 20cc
0001c1 f431
0001c2 20dd
0001c3 f421
0001c4 20ee
0001c5 f411
0001c6 20ff
0001c7 f401
0001c8 f421
0001c9 e380
0001ca 9389
0001cb 940c 024a
0001cd 938f
0001ce 2422
0001cf 20ff
0001d0 f081
0001d1 f46a
0001d2 94f0
0001d3 94e0
0001d4 94d0
0001d5 94c0
0001d6 e081
0001d7 0ec8
0001d8 1cd2
0001d9 1ce2
0001da 1cf2
0001db 2422
0001dc 2cb2
0001dd 940c 0211
0001df 940c 0211
0001e1 20ee
0001e2 f079
0001e3 f462
0001e4 94e0
0001e5 94d0
0001e6 94c0
0001e7 e081
0001e8 0ec8
0001e9 1cd2
0001ea 1ce2
0001eb 1cf2
0001ec 2422
0001ed 2cb2
0001ee 940c 0211
0001f0 940c 0211
0001f2 20dd
0001f3 f071
0001f4 f45a
0001f5 94d0
0001f6 94c0
0001f7 e081
0001f8 0ec8
0001f9 1cd2
0001fa 1ce2
0001fb 1cf2
0001fc 2422
0001fd 2cb2
0001fe 940c 0211
000200 940c 0211
000202 20cc
000203 f069
000204 f452
000205 94c0
000206 e081
000207 0ec8
000208 1cd2
000209 1ce2
00020a 1cf2
00020b 2422
00020c 2cb2
00020d 940c 0211
00020f 940c 0211
000211 918f
000212 20cc
000213 f431
000214 20dd
000215 f421
000216 20ee
000217 f411
000218 20ff
000219 f401
00021a f009
00021b f411
00021c 940c 0245
00021e 938f
00021f 2422
000220 e281
000221 2e58
000222 1877
000223 2488
000224 2499
000225 24aa
000226 1ccc
000227 1cdd
000228 1cee
000229 1cff
00022a 945a
00022b f099
00022c 1c77
00022d 1c88
00022e 1c99
00022f 1caa
000230 e08a
000231 1a78
000232 0882
000233 0892
000234 08a2
000235 f438
000236 e08a
000237 0e78
000238 1c82
000239 1c92
00023a 1ca2
00023b 9488
00023c cfe9
00023d 9408
00023e cfe7
00023f 918f
000240 e380
000241 0e78
000242 9279
000243 940c 0212
000245 e081
000246 16b8
000247 f011
000248 e28d
000249 9389
00024a 940e 0104
00024c 918f      					convert_display total1,total2,total3,total4
                 
                 				/*5ls al 3rd*/
                 
00024d 940e 004b 			CALL GET_KEY //r31 feha al key_pressed , r30 ='n' if num presses otherwise r30=operation
00024f 930f
000250 e001
000251 9ac3
000252 98c1
000253 98c2
000254 bb02
000255 940e 0033
000257 98c3
000258 940e 0036
00025a 910f      			LCD_sendInstruction CLEAR
00025b 930f
00025c e800
00025d 9ac3
00025e 98c1
00025f 98c2
000260 bb02
000261 940e 0033
000263 98c3
000264 940e 0036
000266 910f      			LCD_sendInstruction set_display_address
                 			
000267 36ee      			CPI R30,'n'
000268 f4a1      			BRNE hnkml_OP
                 
000269 930f
00026a 2f0f
00026b 9ac3
00026c 9ac1
00026d 98c2
00026e bb02
00026f 940e 0033
000271 98c3
000272 940e 0036
000274 910f      				LCD_displayChar r31
000275 2f27      				MOV first1,R23
000276 2733      				CLR first2
000277 24cc      				CLR total1
000278 24dd      				CLR total2
000279 24ee      				CLR total3
00027a 24ff      				CLR total4
00027b 940c 0135 				JMP first_num
                 			hnkml_OP:
                 				
00027d 24ee      				clr total3
00027e 24ff      				clr total4
                 
                 				
                 				        
00027f 0169      				MOVW total2:total1 , first2:first1
                 				
000280 2422
000281 938f
000282 e081
000283 2eb8
000284 e080
000285 9389
000286 20cc
000287 f411
000288 20dd
000289 f401
00028a f421
00028b e380
00028c 9389
00028d 940c 02d7
00028f 938f
000290 2422
000291 20dd
000292 f061
000293 f44a
000294 94d0
000295 94c0
000296 e081
000297 0ec8
000298 1cd2
000299 2422
00029a 2cb2
00029b 940c 02ac
00029d 940c 02ac
00029f 20cc
0002a0 f059
0002a1 f442
0002a2 94c0
0002a3 e081
0002a4 0ec8
0002a5 1cd2
0002a6 2422
0002a7 2cb2
0002a8 940c 02ac
0002aa 940c 02ac
0002ac 918f
0002ad 20cc
0002ae f411
0002af 20dd
0002b0 f401
0002b1 f009
0002b2 f411
0002b3 940c 02d2
0002b5 938f
0002b6 2422
0002b7 e181
0002b8 2e58
0002b9 1877
0002ba 2488
0002bb 1ccc
0002bc 1cdd
0002bd 945a
0002be f069
0002bf 1c77
0002c0 1c88
0002c1 e08a
0002c2 1a78
0002c3 0882
0002c4 f428
0002c5 e08a
0002c6 0e78
0002c7 1c82
0002c8 9488
0002c9 cff1
0002ca 9408
0002cb cfef
0002cc 918f
0002cd e380
0002ce 0e78
0002cf 9279
0002d0 940c 02ad
0002d2 e081
0002d3 16b8
0002d4 f011
0002d5 e28d
0002d6 9389
0002d7 940e 0104
0002d9 918f      				convert_display2 total1,total2
0002da 930f
0002db 2f0f
0002dc 9ac3
0002dd 9ac1
0002de 98c2
0002df bb02
0002e0 940e 0033
0002e2 98c3
0002e3 940e 0036
0002e5 910f      				LCD_displayChar r31
                 
0002e6 940c 0158 				jmp IS_OP
                 
                 		multiplication:
                 			
                 				//MULT16x16 first1,first2,second1,second2,total1,total2,total3,total4
0002e8 938f
0002e9 2422
0002ea 2333
0002eb f101
0002ec f4fa
0002ed 9530
0002ee 9520
0002ef e081
0002f0 0f28
0002f1 1d32
0002f2 2422
0002f3 9f35
0002f4 0170
0002f5 9f24
0002f6 0160
0002f7 9f34
0002f8 0cd0
0002f9 1ce1
0002fa 1cf2
0002fb 9f52
0002fc 0cd0
0002fd 1ce1
0002fe 1cf2
0002ff 0196
000300 94c0
000301 94d0
000302 94e0
000303 94f0
000304 e081
000305 0ec8
000306 1cd2
000307 1ce2
000308 1cf2
000309 0196
00030a 940c 031c
00030c 2422
00030d 9f35
00030e 0170
00030f 9f24
000310 0160
000311 9f34
000312 0cd0
000313 1ce1
000314 1cf2
000315 9f52
000316 0cd0
000317 1ce1
000318 1cf2
000319 0196
00031a 940c 031c
00031c 918f      				MULT_FIRSTNEG first1,first2,second1,second2,total1,total2,total3,total4
                 
                 					/*h3rd first1,first2 (clear lcd -->display result)*/
                 						
00031d 938f
00031e e081
00031f 2eb8
000320 e080
000321 9389
000322 20cc
000323 f431
000324 20dd
000325 f421
000326 20ee
000327 f411
000328 20ff
000329 f401
00032a f421
00032b e380
00032c 9389
00032d 940c 03ac
00032f 938f
000330 2422
000331 20ff
000332 f081
000333 f46a
000334 94f0
000335 94e0
000336 94d0
000337 94c0
000338 e081
000339 0ec8
00033a 1cd2
00033b 1ce2
00033c 1cf2
00033d 2422
00033e 2cb2
00033f 940c 0373
000341 940c 0373
000343 20ee
000344 f079
000345 f462
000346 94e0
000347 94d0
000348 94c0
000349 e081
00034a 0ec8
00034b 1cd2
00034c 1ce2
00034d 1cf2
00034e 2422
00034f 2cb2
000350 940c 0373
000352 940c 0373
000354 20dd
000355 f071
000356 f45a
000357 94d0
000358 94c0
000359 e081
00035a 0ec8
00035b 1cd2
00035c 1ce2
00035d 1cf2
00035e 2422
00035f 2cb2
000360 940c 0373
000362 940c 0373
000364 20cc
000365 f069
000366 f452
000367 94c0
000368 e081
000369 0ec8
00036a 1cd2
00036b 1ce2
00036c 1cf2
00036d 2422
00036e 2cb2
00036f 940c 0373
000371 940c 0373
000373 918f
000374 20cc
000375 f431
000376 20dd
000377 f421
000378 20ee
000379 f411
00037a 20ff
00037b f401
00037c f009
00037d f411
00037e 940c 03a7
000380 938f
000381 2422
000382 e281
000383 2e58
000384 1877
000385 2488
000386 2499
000387 24aa
000388 1ccc
000389 1cdd
00038a 1cee
00038b 1cff
00038c 945a
00038d f099
00038e 1c77
00038f 1c88
000390 1c99
000391 1caa
000392 e08a
000393 1a78
000394 0882
000395 0892
000396 08a2
000397 f438
000398 e08a
000399 0e78
00039a 1c82
00039b 1c92
00039c 1ca2
00039d 9488
00039e cfe9
00039f 9408
0003a0 cfe7
0003a1 918f
0003a2 e380
0003a3 0e78
0003a4 9279
0003a5 940c 0374
0003a7 e081
0003a8 16b8
0003a9 f011
0003aa e28d
0003ab 9389
0003ac 940e 0104
0003ae 918f      						convert_display total1,total2,total3,total4
                 
                 					/*5ls al 3rd*/
0003af 940e 004b 				CALL GET_KEY //r31 feha al key_pressed , r30 ='n' if num presses otherwise r30=operation
                 
0003b1 930f
0003b2 e001
0003b3 9ac3
0003b4 98c1
0003b5 98c2
0003b6 bb02
0003b7 940e 0033
0003b9 98c3
0003ba 940e 0036
0003bc 910f      				LCD_sendInstruction CLEAR
0003bd 930f
0003be e800
0003bf 9ac3
0003c0 98c1
0003c1 98c2
0003c2 bb02
0003c3 940e 0033
0003c5 98c3
0003c6 940e 0036
0003c8 910f      				LCD_sendInstruction set_display_address
0003c9 36ee      				CPI R30,'n'
0003ca f4a1      				BRNE OP_MUL
0003cb 930f
0003cc 2f0f
0003cd 9ac3
0003ce 9ac1
0003cf 98c2
0003d0 bb02
0003d1 940e 0033
0003d3 98c3
0003d4 940e 0036
0003d6 910f      					LCD_displayChar r31
0003d7 2f27      					MOV first1,R23
0003d8 2733      					CLR first2
0003d9 24cc      					CLR total1
0003da 24dd      					CLR total2
0003db 24ee      					CLR total3
0003dc 24ff      					CLR total4
                 				
0003dd 940c 0135 					JMP first_num
                 				OP_MUL:
                 					
0003df 940c 027d 					jmp hnkml_OP
                 
                 		subtraction:
                 
0003e1 2422
0003e2 0169
0003e3 1ac4
0003e4 0ad5
0003e5 08e2
0003e6 08f2
0003e7 0196      				SUB16x16 first1,first2,second1,second2,total1,total2,total3,total4
                 				
                 					/*h3rd first1,first2 (clear lcd -->display result)*/
                 						
0003e8 938f
0003e9 e081
0003ea 2eb8
0003eb e080
0003ec 9389
0003ed 20cc
0003ee f431
0003ef 20dd
0003f0 f421
0003f1 20ee
0003f2 f411
0003f3 20ff
0003f4 f401
0003f5 f421
0003f6 e380
0003f7 9389
0003f8 940c 0477
0003fa 938f
0003fb 2422
0003fc 20ff
0003fd f081
0003fe f46a
0003ff 94f0
000400 94e0
000401 94d0
000402 94c0
000403 e081
000404 0ec8
000405 1cd2
000406 1ce2
000407 1cf2
000408 2422
000409 2cb2
00040a 940c 043e
00040c 940c 043e
00040e 20ee
00040f f079
000410 f462
000411 94e0
000412 94d0
000413 94c0
000414 e081
000415 0ec8
000416 1cd2
000417 1ce2
000418 1cf2
000419 2422
00041a 2cb2
00041b 940c 043e
00041d 940c 043e
00041f 20dd
000420 f071
000421 f45a
000422 94d0
000423 94c0
000424 e081
000425 0ec8
000426 1cd2
000427 1ce2
000428 1cf2
000429 2422
00042a 2cb2
00042b 940c 043e
00042d 940c 043e
00042f 20cc
000430 f069
000431 f452
000432 94c0
000433 e081
000434 0ec8
000435 1cd2
000436 1ce2
000437 1cf2
000438 2422
000439 2cb2
00043a 940c 043e
00043c 940c 043e
00043e 918f
00043f 20cc
000440 f431
000441 20dd
000442 f421
000443 20ee
000444 f411
000445 20ff
000446 f401
000447 f009
000448 f411
000449 940c 0472
00044b 938f
00044c 2422
00044d e281
00044e 2e58
00044f 1877
000450 2488
000451 2499
000452 24aa
000453 1ccc
000454 1cdd
000455 1cee
000456 1cff
000457 945a
000458 f099
000459 1c77
00045a 1c88
00045b 1c99
00045c 1caa
00045d e08a
00045e 1a78
00045f 0882
000460 0892
000461 08a2
000462 f438
000463 e08a
000464 0e78
000465 1c82
000466 1c92
000467 1ca2
000468 9488
000469 cfe9
00046a 9408
00046b cfe7
00046c 918f
00046d e380
00046e 0e78
00046f 9279
000470 940c 043f
000472 e081
000473 16b8
000474 f011
000475 e28d
000476 9389
000477 940e 0104
000479 918f      						convert_display total1,total2,total3,total4
                 
                 					/*5ls al 3rd*/
00047a 940e 004b 				CALL GET_KEY //r31 feha al key_pressed , r30 ='n' if num presses otherwise r30=operation
                 
00047c 930f
00047d e001
00047e 9ac3
00047f 98c1
000480 98c2
000481 bb02
000482 940e 0033
000484 98c3
000485 940e 0036
000487 910f      				LCD_sendInstruction CLEAR
000488 930f
000489 e800
00048a 9ac3
00048b 98c1
00048c 98c2
00048d bb02
00048e 940e 0033
000490 98c3
000491 940e 0036
000493 910f      				LCD_sendInstruction set_display_address
000494 36ee      				CPI R30,'n'
000495 f4a1      				BRNE OP_SUB
000496 930f
000497 2f0f
000498 9ac3
000499 9ac1
00049a 98c2
00049b bb02
00049c 940e 0033
00049e 98c3
00049f 940e 0036
0004a1 910f      					LCD_displayChar r31
0004a2 2f27      					MOV first1,R23
0004a3 2733      					CLR first2
0004a4 24cc      					CLR total1
0004a5 24dd      					CLR total2
0004a6 24ee      					CLR total3
0004a7 24ff      					CLR total4
                 				
0004a8 940c 0135 					JMP first_num
                 				OP_SUB:
                 					
0004aa 940c 027d 					jmp hnkml_OP
                 
                 		power:
                 
0004ac 2422
0004ad 938f
0004ae 2344
0004af f411
0004b0 2355
0004b1 f401
0004b2 f459
0004b3 e081
0004b4 2ec8
0004b5 e080
0004b6 2ed8
0004b7 e080
0004b8 2ee8
0004b9 e080
0004ba 2ef8
0004bb 0196
0004bc 940c 051b
0004be 3050
0004bf f5d9
0004c0 3041
0004c1 f5c9
0004c2 e041
0004c3 e050
0004c4 938f
0004c5 2422
0004c6 2333
0004c7 f101
0004c8 f4fa
0004c9 9530
0004ca 9520
0004cb e081
0004cc 0f28
0004cd 1d32
0004ce 2422
0004cf 9f35
0004d0 0170
0004d1 9f24
0004d2 0160
0004d3 9f34
0004d4 0cd0
0004d5 1ce1
0004d6 1cf2
0004d7 9f52
0004d8 0cd0
0004d9 1ce1
0004da 1cf2
0004db 0196
0004dc 94c0
0004dd 94d0
0004de 94e0
0004df 94f0
0004e0 e081
0004e1 0ec8
0004e2 1cd2
0004e3 1ce2
0004e4 1cf2
0004e5 0196
0004e6 940c 04f8
0004e8 2422
0004e9 9f35
0004ea 0170
0004eb 9f24
0004ec 0160
0004ed 9f34
0004ee 0cd0
0004ef 1ce1
0004f0 1cf2
0004f1 9f52
0004f2 0cd0
0004f3 1ce1
0004f4 1cf2
0004f5 0196
0004f6 940c 04f8
0004f8 918f
0004f9 940c 051b
0004fb 0169
0004fc e081
0004fd 1b48
0004fe 0952
0004ff 2e54
000500 2e65
000501 01a9
000502 2055
000503 f411
000504 2066
000505 f401
000506 f0a1
000507 0196
000508 2422
000509 9f35
00050a 0170
00050b 9f24
00050c 0160
00050d 9f34
00050e 0cd0
00050f 1ce1
000510 1cf2
000511 9f52
000512 0cd0
000513 1ce1
000514 1cf2
000515 0196
000516 e081
000517 1a58
000518 0862
000519 940c 0502
00051b 918f      			power16x16 first1,first2,second1,second2,total1,total2,total3,total4
                 				
                 					/*h3rd first1,first2 (clear lcd -->display result)*/
                 						
00051c 938f
00051d e081
00051e 2eb8
00051f e080
000520 9389
000521 20cc
000522 f431
000523 20dd
000524 f421
000525 20ee
000526 f411
000527 20ff
000528 f401
000529 f421
00052a e380
00052b 9389
00052c 940c 05ab
00052e 938f
00052f 2422
000530 20ff
000531 f081
000532 f46a
000533 94f0
000534 94e0
000535 94d0
000536 94c0
000537 e081
000538 0ec8
000539 1cd2
00053a 1ce2
00053b 1cf2
00053c 2422
00053d 2cb2
00053e 940c 0572
000540 940c 0572
000542 20ee
000543 f079
000544 f462
000545 94e0
000546 94d0
000547 94c0
000548 e081
000549 0ec8
00054a 1cd2
00054b 1ce2
00054c 1cf2
00054d 2422
00054e 2cb2
00054f 940c 0572
000551 940c 0572
000553 20dd
000554 f071
000555 f45a
000556 94d0
000557 94c0
000558 e081
000559 0ec8
00055a 1cd2
00055b 1ce2
00055c 1cf2
00055d 2422
00055e 2cb2
00055f 940c 0572
000561 940c 0572
000563 20cc
000564 f069
000565 f452
000566 94c0
000567 e081
000568 0ec8
000569 1cd2
00056a 1ce2
00056b 1cf2
00056c 2422
00056d 2cb2
00056e 940c 0572
000570 940c 0572
000572 918f
000573 20cc
000574 f431
000575 20dd
000576 f421
000577 20ee
000578 f411
000579 20ff
00057a f401
00057b f009
00057c f411
00057d 940c 05a6
00057f 938f
000580 2422
000581 e281
000582 2e58
000583 1877
000584 2488
000585 2499
000586 24aa
000587 1ccc
000588 1cdd
000589 1cee
00058a 1cff
00058b 945a
00058c f099
00058d 1c77
00058e 1c88
00058f 1c99
000590 1caa
000591 e08a
000592 1a78
000593 0882
000594 0892
000595 08a2
000596 f438
000597 e08a
000598 0e78
000599 1c82
00059a 1c92
00059b 1ca2
00059c 9488
00059d cfe9
00059e 9408
00059f cfe7
0005a0 918f
0005a1 e380
0005a2 0e78
0005a3 9279
0005a4 940c 0573
0005a6 e081
0005a7 16b8
0005a8 f011
0005a9 e28d
0005aa 9389
0005ab 940e 0104
0005ad 918f      						convert_display total1,total2,total3,total4
                 
                 					/*5ls al 3rd*/
0005ae 940e 004b 				CALL GET_KEY //r31 feha al key_pressed , r30 ='n' if num presses otherwise r30=operation
                 
0005b0 930f
0005b1 e001
0005b2 9ac3
0005b3 98c1
0005b4 98c2
0005b5 bb02
0005b6 940e 0033
0005b8 98c3
0005b9 940e 0036
0005bb 910f      				LCD_sendInstruction CLEAR
0005bc 930f
0005bd e800
0005be 9ac3
0005bf 98c1
0005c0 98c2
0005c1 bb02
0005c2 940e 0033
0005c4 98c3
0005c5 940e 0036
0005c7 910f      				LCD_sendInstruction set_display_address
0005c8 36ee      				CPI R30,'n'
0005c9 f4a1      				BRNE OP_power
0005ca 930f
0005cb 2f0f
0005cc 9ac3
0005cd 9ac1
0005ce 98c2
0005cf bb02
0005d0 940e 0033
0005d2 98c3
0005d3 940e 0036
0005d5 910f      					LCD_displayChar r31
0005d6 2f27      					MOV first1,R23
0005d7 2733      					CLR first2
0005d8 24cc      					CLR total1
0005d9 24dd      					CLR total2
0005da 24ee      					CLR total3
0005db 24ff      					CLR total4
                 				
0005dc 940c 0135 					JMP first_num
                 				OP_power:
                 					
0005de 940c 027d 					jmp hnkml_OP
                 		others:
0005e0 940e 0128 			CALL void_SETUP
                 
0005e2 940c 0135 jmp void_LOOP
0005e4 9508      RET
                 
                 


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

"ATmega32A" register use summary:
r0 :  24 r1 :  22 r2 : 174 r3 :  10 r4 :   0 r5 :  13 r6 :   3 r7 :  35 
r8 :  20 r9 :  16 r10:  16 r11:  28 r12:  94 r13:  99 r14:  72 r15:  68 
r16:  84 r17:  18 r18:  42 r19:  45 r20:  30 r21:  29 r22:   5 r23:  16 
r24: 191 r25:  93 r26:   0 r27:   0 r28:   3 r29:   2 r30:  22 r31:  24 
x  :   0 y  :  21 z  :   0 
Registers used: 30 out of 35 (85.7%)

"ATmega32A" instruction use summary:
.lds  :   0 .sts  :   0 adc   : 100 add   :  49 adiw  :   0 and   :   0 
andi  :  11 asr   :   0 bclr  :   0 bld   :   0 brbc  :   0 brbs  :   0 
brcc  :   5 brcs  :   0 break :   0 breq  :  56 brge  :   0 brhc  :   0 
brhs  :   0 brid  :   0 brie  :   0 brlo  :   0 brlt  :   0 brmi  :   0 
brne  :  70 brpl  :  21 brsh  :   0 brtc  :   0 brts  :   0 brvc  :   0 
brvs  :   0 bset  :   0 bst   :   0 call  :  60 cbi   :  50 cbr   :   0 
clc   :   5 clh   :   0 cli   :   0 cln   :   0 clr   :  87 cls   :   0 
clt   :   0 clv   :   0 clz   :   0 com   :  61 cp    :   5 cpc   :   0 
cpi   :  36 cpse  :   0 dec   :   8 eor   :   0 fmul  :   0 fmuls :   0 
fmulsu:   0 icall :   0 ijmp  :   0 in    :  11 inc   :   0 jmp   : 100 
ld    :   1 ldd   :   0 ldi   : 153 lds   :   0 lpm   :   0 lsl   :   0 
lsr   :   0 mov   :  63 movw  :  32 mul   :  24 muls  :   0 mulsu :   0 
neg   :   0 nop   :   4 or    :   0 ori   :   0 out   :  29 pop   :  52 
push  :  52 rcall :   0 ret   :  10 reti  :   0 rjmp  :  10 rol   :  36 
ror   :   0 sbc   :  21 sbci  :   0 sbi   :  27 sbic  :   0 sbis  :   0 
sbiw  :   0 sbr   :   0 sbrc  :   0 sbrs  :   0 sec   :   5 seh   :   0 
sei   :   0 sen   :   0 ser   :   0 ses   :   0 set   :   0 sev   :   0 
sez   :   0 sleep :   0 spm   :   0 st    :  20 std   :   0 sts   :   0 
sub   :  14 subi  :   0 swap  :   0 tst   :  61 wdr   :   0 
Instructions used: 35 out of 113 (31.0%)

"ATmega32A" memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x000000 0x000bca   3018      0   3018   32768   9.2%
[.dseg] 0x000060 0x00006d      0     13     13    2048   0.6%
[.eseg] 0x000000 0x000000      0      0      0    1024   0.0%

Assembly complete, 0 errors, 0 warnings
